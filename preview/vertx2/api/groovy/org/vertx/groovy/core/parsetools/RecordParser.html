<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- **************************************************************** -->
<!-- *  PLEASE KEEP COMPLICATED EXPRESSIONS OUT OF THESE TEMPLATES, * -->
<!-- *  i.e. only iterate & print data where possible. Thanks, Jez. * -->
<!-- **************************************************************** -->

<html>
<head>
<!-- Generated by groovydoc (2.1.5) on Wed Jul 17 20:34:40 BST 2013 -->
<title>RecordParser (mod-lang-groovy 2.0.0-final API)</title>
<meta name="date" content="2013-07-17">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="../../../../../groovy.ico" type="image/x-icon" rel="shortcut icon">
<link href="../../../../../groovy.ico" type="image/x-icon" rel="icon">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="RecordParser (mod-lang-groovy 2.0.0-final API)";
    }
}
</script>
<noscript>
</noscript>

</head><body onload="windowTitle();" bgcolor="white">
<hr>

<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>

  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <!--<TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  -->
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Groovy Documentation</b>
</EM></TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><!--<FONT SIZE="-2">
&nbsp;<A HREF="../../../../../groovy/lang/ExpandoMetaClass.ExpandoMetaProperty.html" title="class in groovy.lang"><B>PREV CLASS</B></A>&nbsp;

&nbsp;<A HREF="../../../../../groovy/lang/GroovyClassLoader.html" title="class in groovy.lang"><B>NEXT CLASS</B></A></FONT>--></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/vertx/groovy/core/parsetools/RecordParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="RecordParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<script type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-frame.html"><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
  <A HREF="../../../../../allclasses-frame.html"><B>All Classes</B></A>
</noscript>

</FONT></TD>

</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- ========= END OF TOP NAVBAR ========= -->


<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>

<FONT SIZE="-1">
org.vertx.groovy.core.parsetools</FONT>
<BR>

<span CLASS="ClassTitleFont">[Groovy] Class RecordParser</span></H2>
<pre>java.lang.Object
  <img src='../../../../../inherit.gif'>org.vertx.groovy.core.parsetools.RecordParser
</pre><hr>
<PRE>@groovy.transform.CompileStatic
class RecordParser

</PRE>

<P>
 A helper class which allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed
 size records.<p>
 Instances of this class take as input Buffer instances containing raw bytes, and output records.<p>
 For example, if I had a simple ASCII text protocol delimited by '\n' and the input was the following:<p>
 <pre>
 buffer1:HELLO\nHOW ARE Y
 buffer2:OU?\nI AM
 buffer3: DOING OK
 buffer4:\n
 </pre>
 Then the output would be:<p>
 <pre>
 buffer1:HELLO
 buffer2:HOW ARE YOU?
 buffer3:I AM DOING OK
 </pre>
 Instances of this class can be changed between delimited mode and fixed size record mode on the fly as
 individual records are read, this allows you to parse protocols where, for example, the first 5 records might
 all be fixed size (of potentially different sizes), followed by some delimited records, followed by more fixed
 size records.<p>
 Instances of this class can't currently be used for protocols where the text is encoded with something other than
 a 1-1 byte-char mapping. TODO extend this class to cope with arbitrary character encodings<p>
 <DL><DT><B>Authors:</B></DT><DD><a href="http://tfox.org">Tim Fox</a></DD></DL>
</P>
<hr>


<!-- =========== NESTED CLASS SUMMARY =========== -->

<A NAME="nested_summary"><!-- --></A>


<!-- =========== ENUM CONSTANT SUMMARY =========== -->

<A NAME="enum_constant_summary"><!-- --></A>


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>


<!-- =========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>


<!-- =========== ELEMENT SUMMARY =========== -->



<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>

    <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR CLASS="TableHeadingColor">
    <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2" CLASS="ClassHeadingFont">
    <B>Method Summary</B></FONT></TH>
    </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>void</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#delimitedMode(java.lang.String)">delimitedMode</a></b>(java.lang.String delim)</CODE>
            <BR>
            <P>Flip the parser into delimited mode, and where the delimiter can be represented
 by the String <TT>delim</TT> endcoded in latin-1 . </P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>void</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#delimitedMode(byte[])">delimitedMode</a></b>(byte[] delim)</CODE>
            <BR>
            <P>Flip the parser into delimited mode, and where the delimiter can be represented
 by the delimiter <TT>delim</TT>.</P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>void</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#fixedSizeMode(int)">fixedSizeMode</a></b>(int size)</CODE>
            <BR>
            <P>Flip the parser into fixed size mode, where the record size is specified by <TT>size</TT> in bytes.</P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>void</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#handle(org.vertx.groovy.core.buffer.Buffer)">handle</a></b>(<a href='../../../../../org/vertx/groovy/core/buffer/Buffer.html'>Buffer</a> data)</CODE>
            <BR>
            <P></P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>static&nbsp;byte[]</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#latin1StringToBytes(java.lang.String)">latin1StringToBytes</a></b>(java.lang.String str)</CODE>
            <BR>
            <P>Helper method to convert a latin-1 String to an array of bytes for use as a delimiter
 Please do not use this for non latin-1 characters</P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a></CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#newDelimited(java.lang.String, groovy.lang.Closure)">newDelimited</a></b>(java.lang.String delim, groovy.lang.Closure output)</CODE>
            <BR>
            <P>Create a new <TT>RecordParser</TT> instance, initially in delimited mode, and where the delimiter can be represented
 by the String {@code} delim endcoded in latin-1 . </P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a></CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#newDelimited(byte[], groovy.lang.Closure)">newDelimited</a></b>(byte[] delim, groovy.lang.Closure output)</CODE>
            <BR>
            <P>Create a new <TT>RecordParser</TT> instance, initially in delimited mode, and where the delimiter can be represented
 by the <TT>byte[]</TT> delim.</P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a></CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#newFixed(int, groovy.lang.Closure)">newFixed</a></b>(int size, groovy.lang.Closure output)</CODE>
            <BR>
            <P>Create a new <TT>RecordParser</TT> instance, initially in fixed size mode, and where the record size is specified
 by the <TT>size</TT> parameter.</P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>void</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#setOutput(groovy.lang.Closure)">setOutput</a></b>(groovy.lang.Closure output)</CODE>
            <BR>
            <P></P>
        </TD>
        </TR>
    
        <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1" CLASS="ClassItemFont">
            <CODE>groovy.lang.Closure</CODE></FONT>
        </TD>
        <TD>
            <CODE><b><a href="#toClosure()">toClosure</a></b>()</CODE>
            <BR>
            <P>Convert to a closure so it can be plugged into data handlers</P>
        </TD>
        </TR>
    
    </TABLE>
    &nbsp;
<table BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
                <tr CLASS="TableSubHeadingColor"><th ALIGN="left" COLSPAN="2">
                <b>Methods inherited from class java.lang.Object</b>
                </th></tr>
                <tr class="TableRowColor"><td colspan='2'>java.lang.Object#wait(long, int), java.lang.Object#wait(long), java.lang.Object#wait(), java.lang.Object#equals(java.lang.Object), java.lang.Object#toString(), java.lang.Object#hashCode(), java.lang.Object#getClass(), java.lang.Object#notify(), java.lang.Object#notifyAll()</td></tr>
                </table>
                &nbsp;

<P>

<!-- ============ ENUM CONSTANT DETAIL ========== -->

<A NAME="enum_constant_detail"><!-- --></A>


<!-- =========== FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>


<!-- =========== PROPERTY DETAIL =========== -->

<A NAME="prop_detail"><!-- --></A>


<!-- =========== ELEMENT DETAIL =========== -->

<A NAME="element_detail"><!-- --></A>


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>

    <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
    <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
    <B>Method Detail</B></FONT></TH>
    </TR>
    </TABLE>
    
        <A NAME="delimitedMode(java.lang.String)"><!-- --></A><H3>
        delimitedMode</H3>
        <PRE>void <B>delimitedMode</B>(java.lang.String delim)</PRE>
        <DL>
        <DD> Flip the parser into delimited mode, and where the delimiter can be represented
 by the String <TT>delim</TT> endcoded in latin-1 . Don't use this if your String contains other than latin-1 characters.<p>
 This method can be called multiple times with different values of delim while data is being parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="delimitedMode(byte[])"><!-- --></A><H3>
        delimitedMode</H3>
        <PRE>void <B>delimitedMode</B>(byte[] delim)</PRE>
        <DL>
        <DD> Flip the parser into delimited mode, and where the delimiter can be represented
 by the delimiter <TT>delim</TT>.<p>
 This method can be called multiple times with different values of delim while data is being parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="fixedSizeMode(int)"><!-- --></A><H3>
        fixedSizeMode</H3>
        <PRE>void <B>fixedSizeMode</B>(int size)</PRE>
        <DL>
        <DD> Flip the parser into fixed size mode, where the record size is specified by <TT>size</TT> in bytes.<p>
 This method can be called multiple times with different values of size while data is being parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="handle(org.vertx.groovy.core.buffer.Buffer)"><!-- --></A><H3>
        handle</H3>
        <PRE>void <B>handle</B>(<a href='../../../../../org/vertx/groovy/core/buffer/Buffer.html'>Buffer</a> data)</PRE>
        <DL>
        <DD>
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="latin1StringToBytes(java.lang.String)"><!-- --></A><H3>
        latin1StringToBytes</H3>
        <PRE>static&nbsp;byte[] <B>latin1StringToBytes</B>(java.lang.String str)</PRE>
        <DL>
        <DD> Helper method to convert a latin-1 String to an array of bytes for use as a delimiter
 Please do not use this for non latin-1 characters
   <DL><DT><B>Parameters:</B></DT><DD>str</DD></DL><DL><DT><B>Returns:</B></DT><DD>The byte[] form of the string</DD></DL>
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="newDelimited(java.lang.String, groovy.lang.Closure)"><!-- --></A><H3>
        newDelimited</H3>
        <PRE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a> <B>newDelimited</B>(java.lang.String delim, groovy.lang.Closure output)</PRE>
        <DL>
        <DD> Create a new <TT>RecordParser</TT> instance, initially in delimited mode, and where the delimiter can be represented
 by the String {@code} delim endcoded in latin-1 . Don't use this if your String contains other than latin-1 characters.<p>
 <TT>output</TT> Will receive whole records which have been parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="newDelimited(byte[], groovy.lang.Closure)"><!-- --></A><H3>
        newDelimited</H3>
        <PRE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a> <B>newDelimited</B>(byte[] delim, groovy.lang.Closure output)</PRE>
        <DL>
        <DD> Create a new <TT>RecordParser</TT> instance, initially in delimited mode, and where the delimiter can be represented
 by the <TT>byte[]</TT> delim.<p>
 <TT>output</TT> Will receive whole records which have been parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="newFixed(int, groovy.lang.Closure)"><!-- --></A><H3>
        newFixed</H3>
        <PRE>static&nbsp;<a href='../../../../../org/vertx/groovy/core/parsetools/RecordParser.html'>RecordParser</a> <B>newFixed</B>(int size, groovy.lang.Closure output)</PRE>
        <DL>
        <DD> Create a new <TT>RecordParser</TT> instance, initially in fixed size mode, and where the record size is specified
 by the <TT>size</TT> parameter.<p>
 <TT>output</TT> Will receive whole records which have been parsed.
   
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="setOutput(groovy.lang.Closure)"><!-- --></A><H3>
        setOutput</H3>
        <PRE>void <B>setOutput</B>(groovy.lang.Closure output)</PRE>
        <DL>
        <DD>
        </DD>
        <P>
        </DL>
        <HR>
    
        <A NAME="toClosure()"><!-- --></A><H3>
        toClosure</H3>
        <PRE>groovy.lang.Closure <B>toClosure</B>()</PRE>
        <DL>
        <DD> Convert to a closure so it can be plugged into data handlers
   <DL><DT><B>Returns:</B></DT><DD>a Closure</DD></DL>
        </DD>
        <P>
        </DL>
        <HR>
    
    &nbsp;


<!-- ========= END OF CLASS DATA ========= -->
<p>Groovy Documentation</p>
<hr>

</body>
</html>
