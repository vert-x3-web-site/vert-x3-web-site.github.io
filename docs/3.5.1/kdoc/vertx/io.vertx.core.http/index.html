<HTML>
<HEAD>
<meta charset="UTF-8">
<title>io.vertx.core.http - vertx</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">vertx</a>&nbsp;/&nbsp;<a href=".">io.vertx.core.http</a><br/>
<br/>
<h2>Package io.vertx.core.http</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-case-insensitive-headers/index.html">CaseInsensitiveHeaders</a></p>
</td>
<td>
<code><span class="keyword">class </span><span class="identifier">CaseInsensitiveHeaders</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">MultiMap</span></code>
<p>This multi-map implementation has case insensitive keys, and can be used to hold some HTTP headers prior to making an HTTP request.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-client-response/index.html">HttpClientResponse</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">HttpClientResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">Buffer</span><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP response. 
<p> Vert.x provides you with one of these via the handler that was provided when creating the io.vertx.core.http.HttpClientRequest or that was set on the io.vertx.core.http.HttpClientRequest instance. </p>
<p> It implements io.vertx.core.streams.ReadStream so it can be used with io.vertx.core.streams.Pump to pump data with flow control.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-connection/index.html">HttpConnection</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">HttpConnection</span></code>
<p>Represents an HTTP connection.  HTTP/1.x connection provides an limited implementation, the following methods are implemented: <ul> <li><code><a href="-http-connection/close.html">#close</a></code></li>
 <li><code><a href="#">#closeHandler</a></code></li>
 <li><code><a href="#">#exceptionHandler</a></code></li>
 </ul>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-headers/index.html">HttpHeaders</a></p>
</td>
<td>
<code><span class="keyword">class </span><span class="identifier">HttpHeaders</span></code>
<p>Contains often used Header names. 
<p> It also contains a utility method to create optimized CharSequence which can be used as header name and value.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server-file-upload/index.html">HttpServerFileUpload</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">HttpServerFileUpload</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">Buffer</span><span class="symbol">&gt;</span></code>
<p>Represents an file upload from an HTML FORM.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server-response/index.html">HttpServerResponse</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">HttpServerResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">Buffer</span><span class="symbol">&gt;</span></code>
<p>Represents a server-side HTTP response. 
<p> An instance of this is created and associated to every instance of HttpServerRequest that. </p>
<p> It allows the developer to control the HTTP response that is sent back to the client for a particular HTTP request. </p>
<p> It contains methods that allow HTTP headers and trailers to be set, and for a body to be written out to the response. </p>
<p> It also allows files to be streamed by the kernel directly from disk to the outgoing HTTP connection, bypassing user space altogether (where supported by the underlying operating system). This is a very efficient way of serving files from the server since buffers do not have to be read one by one from the file and written to the outgoing socket. </p>
<p> It implements io.vertx.core.streams.WriteStream so it can be used with io.vertx.core.streams.Pump to pump data with flow control.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-request-options/index.html">RequestOptions</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">RequestOptions</span></code>
<p>Options describing how an HttpClient will make connect to make a request.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-server-web-socket/index.html">ServerWebSocket</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ServerWebSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WebSocketBase</span></code>
<p>Represents a server side WebSocket. 
<p> Instances of this class are passed into a <code><a href="#">io.vertx.core.http.HttpServer#websocketHandler</a></code> or provided when a WebSocket handshake is manually <code><a href="#">HttpServerRequest#upgrade</a></code>ed.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-web-socket/index.html">WebSocket</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">WebSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WebSocketBase</span></code>
<p>Represents a client-side WebSocket.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-websocket-version/index.html">WebsocketVersion</a></p>
</td>
<td>
<code><span class="keyword">class </span><span class="identifier">WebsocketVersion</span></code>
<p>Represents the WebSocket version</p>
</td>
</tr>
</tbody>
</table>
<h3>Exceptions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-connection-pool-too-busy-exception/index.html">ConnectionPoolTooBusyException</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">ConnectionPoolTooBusyException</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">VertxException</span></code>
<p>Represents a failure to add a HttpClientRequest to the wait queue on an ConnectionManager. 
<p> If an HttpClient receives a request but is already handling maxPoolSize requests it will attempt to put the new request on it's wait queue. If the maxWaitQueueSize is set and the new request would cause the wait queue to exceed that size then the request will receive this exception.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="-stream-reset-exception/index.html">StreamResetException</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">StreamResetException</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">VertxException</span></code>
<p>This exception signals a stream reset, it is used only for HTTP/2.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-websocket-rejected-exception/index.html">WebsocketRejectedException</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">WebsocketRejectedException</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">VertxException</span></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
