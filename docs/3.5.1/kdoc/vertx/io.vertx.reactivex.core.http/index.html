<HTML>
<HEAD>
<meta charset="UTF-8">
<title>io.vertx.reactivex.core.http - vertx</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">vertx</a>&nbsp;/&nbsp;<a href=".">io.vertx.reactivex.core.http</a><br/>
<br/>
<h2>Package io.vertx.reactivex.core.http</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-http-client/index.html">HttpClient</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClient</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.metrics/-measured/index.html"><span class="identifier">Measured</span></a></code>
<p>An asynchronous HTTP client. 
<p> It allows you to make requests to HTTP servers, and a single client can make requests to any server. </p>
<p> It also allows you to open WebSockets to servers. </p>
<p> The client can also pool HTTP connections. </p>
<p> For pooling to occur, keep-alive must be true on the io.vertx.core.http.HttpClientOptions (default is true). In this case connections will be pooled and re-used if there are pending HTTP requests waiting to get a connection, otherwise they will be closed. </p>
<p> This gives the benefits of keep alive when the client is loaded but means we don't keep connections hanging around unnecessarily when there would be no benefits anyway. </p>
<p> The client also supports pipe-lining of requests. Pipe-lining means another request is sent on the same connection before the response from the preceding one has returned. Pipe-lining is not appropriate for all requests. </p>
<p> To enable pipe-lining, it must be enabled on the io.vertx.core.http.HttpClientOptions (default is false). </p>
<p> When pipe-lining is enabled the connection will be automatically closed when all in-flight responses have returned and there are no outstanding pending requests to write. </p>
<p> The client is designed to be reused between requests. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClient non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-client-request/index.html">HttpClientRequest</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClientRequest</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../io.vertx.reactivex.core.streams/-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="-http-client-response/index.html"><span class="identifier">HttpClientResponse</span></a><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP request. 
<p> Instances are created by an io.vertx.reactivex.core.http.HttpClient instance, via one of the methods corresponding to the specific HTTP methods, or the generic request methods. On creation the request will not have been written to the wire. </p>
<p> Once a request has been obtained, headers can be set on it, and data can be written to its body if required. Once you are ready to send the request, one of the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> methods should be called. </p>
<p> Nothing is actually sent until the request has been internally assigned an HTTP connection. </p>
<p> The io.vertx.reactivex.core.http.HttpClient instance will return an instance of this class immediately, even if there are no HTTP connections available in the pool. Any requests sent before a connection is assigned will be queued internally and actually sent when an HTTP connection becomes available from the pool. </p>
<p> The headers of the request are queued for writing either when the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> method is called, or, when the first part of the body is written, whichever occurs first. </p>
<p> This class supports both chunked and non-chunked HTTP. </p>
<p> It implements io.vertx.reactivex.core.streams.WriteStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
<p> An example of using this class is as follows: </p>
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClientRequest non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-client-response/index.html">HttpClientResponse</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClientResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP response. 
<p> Vert.x provides you with one of these via the handler that was provided when creating the io.vertx.reactivex.core.http.HttpClientRequest or that was set on the io.vertx.reactivex.core.http.HttpClientRequest instance. </p>
<p> It implements io.vertx.reactivex.core.streams.ReadStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClientResponse non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-connection/index.html">HttpConnection</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpConnection</span></code>
<p>Represents an HTTP connection.  HTTP/1.x connection provides an limited implementation, the following methods are implemented: <ul> <li><code><a href="-http-connection/close.html">io.vertx.reactivex.core.http.HttpConnection#close</a></code></li>
 <li><code><a href="#">io.vertx.reactivex.core.http.HttpConnection#closeHandler</a></code></li>
 <li><code><a href="#">io.vertx.reactivex.core.http.HttpConnection#exceptionHandler</a></code></li>
 </ul>
  NOTE: This class has been automatically generated from the io.vertx.core.http.HttpConnection non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-frame/index.html">HttpFrame</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpFrame</span></code>
<p>An HTTP/2 frame.  NOTE: This class has been automatically generated from the io.vertx.core.http.HttpFrame non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server/index.html">HttpServer</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServer</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.metrics/-measured/index.html"><span class="identifier">Measured</span></a></code>
<p>An HTTP and WebSockets server. 
<p> You receive HTTP requests by providing a <code><a href="#">io.vertx.reactivex.core.http.HttpServer#requestHandler</a></code>. As requests arrive on the server the handler will be called with the requests. </p>
<p> You receive WebSockets by providing a <code><a href="#">io.vertx.reactivex.core.http.HttpServer#websocketHandler</a></code>. As WebSocket connections arrive on the server, the WebSocket is passed to the handler. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServer non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server-file-upload/index.html">HttpServerFileUpload</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerFileUpload</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents an file upload from an HTML FORM.  NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerFileUpload non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server-request/index.html">HttpServerRequest</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerRequest</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a server-side HTTP request. 
<p> Instances are created for each request and passed to the user via a handler. </p>
<p> Each instance of this class is associated with a corresponding io.vertx.reactivex.core.http.HttpServerResponse instance via <code><a href="-http-server-request/response.html">io.vertx.reactivex.core.http.HttpServerRequest#response</a></code>.</p>
<p> It implements io.vertx.reactivex.core.streams.ReadStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerRequest non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-http-server-response/index.html">HttpServerResponse</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a server-side HTTP response. 
<p> An instance of this is created and associated to every instance of io.vertx.reactivex.core.http.HttpServerRequest that. </p>
<p> It allows the developer to control the HTTP response that is sent back to the client for a particular HTTP request. </p>
<p> It contains methods that allow HTTP headers and trailers to be set, and for a body to be written out to the response. </p>
<p> It also allows files to be streamed by the kernel directly from disk to the outgoing HTTP connection, bypassing user space altogether (where supported by the underlying operating system). This is a very efficient way of serving files from the server since buffers do not have to be read one by one from the file and written to the outgoing socket. </p>
<p> It implements io.vertx.reactivex.core.streams.WriteStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerResponse non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-server-web-socket/index.html">ServerWebSocket</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">ServerWebSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-web-socket-base/index.html"><span class="identifier">WebSocketBase</span></a></code>
<p>Represents a server side WebSocket. 
<p> Instances of this class are passed into a <code><a href="#">io.vertx.reactivex.core.http.HttpServer#websocketHandler</a></code> or provided when a WebSocket handshake is manually <code><a href="-http-server-request/upgrade.html">io.vertx.reactivex.core.http.HttpServerRequest#upgrade</a></code>ed. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.ServerWebSocket non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-web-socket/index.html">WebSocket</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">WebSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-web-socket-base/index.html"><span class="identifier">WebSocketBase</span></a></code>
<p>Represents a client-side WebSocket.  NOTE: This class has been automatically generated from the io.vertx.core.http.WebSocket non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-web-socket-base/index.html">WebSocketBase</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">WebSocketBase</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../io.vertx.reactivex.core.streams/-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../io.vertx.reactivex.core.streams/-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Base WebSocket implementation. 
<p> It implements both and so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.WebSocketBase non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-web-socket-frame/index.html">WebSocketFrame</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">WebSocketFrame</span></code>
<p>A WebSocket frame that represents either text or binary data. 
<p> A WebSocket message is composed of one or more WebSocket frames. </p>
<p> If there is a just a single frame in the message then a single text or binary frame should be created with final = true. </p>
<p> If there are more than one frames in the message, then the first frame should be a text or binary frame with final = false, followed by one or more continuation frames. The last continuation frame should have final = true. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.WebSocketFrame non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
