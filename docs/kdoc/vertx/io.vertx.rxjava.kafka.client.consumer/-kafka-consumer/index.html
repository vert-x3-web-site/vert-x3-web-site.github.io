<HTML>
<HEAD>
<meta charset="UTF-8">
<title>KafkaConsumer - vertx</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">vertx</a>&nbsp;/&nbsp;<a href="../index.html">io.vertx.rxjava.kafka.client.consumer</a>&nbsp;/&nbsp;<a href=".">KafkaConsumer</a><br/>
<br/>
<h1>KafkaConsumer</h1>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">KafkaConsumerRecord</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Vert.x Kafka consumer. 
<p> You receive Kafka records by providing a <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#handler</a></code>. As messages arrive the handler will be called with the records. </p>
<p> The <code><a href="pause.html">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#pause</a></code> and <code><a href="resume.html">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#resume</a></code> provides global control over reading the records from the consumer. </p>
<p> The <code><a href="pause.html">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#pause</a></code> and <code><a href="resume.html">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#resume</a></code> provides finer grained control over reading records for specific Topic/Partition, these are Kafka's specific operations. </p>
 NOTE: This class has been automatically generated from the io.vertx.kafka.client.consumer.KafkaConsumer non RX-ified interface using Vert.x codegen.</p>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-init-.html">&lt;init&gt;</a></p>
</td>
<td>
<code><span class="identifier">KafkaConsumer</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$<init>(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )))/delegate">delegate</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.kafka.client.consumer/-kafka-consumer/index.html"><span class="identifier">KafkaConsumer</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">)</span></code><br/>
<code><span class="identifier">KafkaConsumer</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$<init>(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.V)))/delegate">delegate</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.kafka.client.consumer/-kafka-consumer/index.html"><span class="identifier">KafkaConsumer</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$<init>(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.V)))/typeArg_0">typeArg_0</span><span class="symbol">:</span>&nbsp;<span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$<init>(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.V)))/typeArg_1">typeArg_1</span><span class="symbol">:</span>&nbsp;<span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">)</span></code></td>
</tr>
</tbody>
</table>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="__-t-y-p-e_-a-r-g.html">__TYPE_ARG</a></p>
</td>
<td>
<code><span class="keyword">static</span> <span class="keyword">val </span><span class="identifier">__TYPE_ARG</span><span class="symbol">: </span><span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="__type-arg_0.html">__typeArg_0</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">__typeArg_0</span><span class="symbol">: </span><span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="__type-arg_1.html">__typeArg_1</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">__typeArg_1</span><span class="symbol">: </span><span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="assign.html">assign</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Manually assign a partition to this consumer.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Manually assign a list of partition to this consumer.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Manually assign a partition to this consumer. 
<p> Due to internal buffering of messages, when reassigning the old partition may remain in effect (as observed by the record handler)} until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new partition.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assign(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Manually assign a list of partition to this consumer. 
<p> Due to internal buffering of messages, when reassigning the old set of partitions may remain in effect (as observed by the record handler)} until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new set of partitions.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="assignment.html">assignment</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assignment</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$assignment(io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Get the set of partitions currently assigned to this consumer.</p>
</td>
</tr>
<tr>
<td>
<p><a href="batch-handler.html">batchHandler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">batchHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$batchHandler(io.vertx.core.Handler((io.vertx.rxjava.kafka.client.consumer.KafkaConsumerRecords((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.K, io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.V)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="../-kafka-consumer-records/index.html"><span class="identifier">KafkaConsumerRecords</span></a><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Set the handler to be used when batches of messages are fetched from the Kafka server. Batch handlers need to take care not to block the event loop when dealing with large batches. It is better to process records individually using the io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.</p>
</td>
</tr>
<tr>
<td>
<p><a href="beginning-offsets.html">beginningOffsets</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">beginningOffsets</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$beginningOffsets(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$beginningOffsets(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Get the first offset for the given partitions.</p>
</td>
</tr>
<tr>
<td>
<p><a href="close.html">close</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">close</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code><br/>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">close</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$close(io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Close the consumer</p>
</td>
</tr>
<tr>
<td>
<p><a href="commit.html">commit</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">commit</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code><br/>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">commit</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$commit(io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Commit current offsets for all the subscribed list of topics and partition.</p>
</td>
</tr>
<tr>
<td>
<p><a href="committed.html">committed</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">committed</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$committed(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((io.vertx.kafka.client.consumer.OffsetAndMetadata)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$committed(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((io.vertx.kafka.client.consumer.OffsetAndMetadata)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">OffsetAndMetadata</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Get the last committed offset for the given partition (whether the commit happened by this process or another).</p>
</td>
</tr>
<tr>
<td>
<p><a href="create.html">create</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">create</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )))/vertx">vertx</span><span class="symbol">:</span>&nbsp;<span class="identifier">Vertx</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )))/config">config</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html"><span class="identifier">MutableMap</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">create</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.K)), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.V)))/vertx">vertx</span><span class="symbol">:</span>&nbsp;<span class="identifier">Vertx</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.K)), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.V)))/config">config</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html"><span class="identifier">MutableMap</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.K)), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.V)))/keyType">keyType</span><span class="symbol">:</span>&nbsp;<span class="identifier">Class</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$create(io.vertx.rxjava.core.Vertx, kotlin.collections.MutableMap((kotlin.String, )), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.K)), java.lang.Class((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.create.V)))/valueType">valueType</span><span class="symbol">:</span>&nbsp;<span class="identifier">Class</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Create a new KafkaConsumer instance</p>
</td>
</tr>
<tr>
<td>
<p><a href="end-handler.html">endHandler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">endHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$endHandler(io.vertx.core.Handler((java.lang.Void)))/endHandler">endHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="end-offsets.html">endOffsets</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">endOffsets</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$endOffsets(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$endOffsets(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Get the last offset for the given partition. The last offset of a partition is the offset of the upcoming message, i.e. the offset of the last available message + 1.</p>
</td>
</tr>
<tr>
<td>
<p><a href="equals.html">equals</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">equals</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$equals(kotlin.Any)/other">other</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">?</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="exception-handler.html">exceptionHandler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">exceptionHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$exceptionHandler(io.vertx.core.Handler((kotlin.Throwable)))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html"><span class="identifier">Throwable</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="get-delegate.html">getDelegate</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getDelegate</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../io.vertx.kafka.client.consumer/-kafka-consumer/index.html"><span class="identifier">KafkaConsumer</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="handler.html">handler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">handler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$handler(io.vertx.core.Handler((io.vertx.rxjava.kafka.client.consumer.KafkaConsumerRecord((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.K, io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.V)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">KafkaConsumerRecord</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="hash-code.html">hashCode</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">hashCode</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="new-instance.html">newInstance</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$newInstance(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )))/arg">arg</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.kafka.client.consumer/-kafka-consumer/index.html"><span class="identifier">KafkaConsumer</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$newInstance(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.V)))/arg">arg</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.kafka.client.consumer/-kafka-consumer/index.html"><span class="identifier">KafkaConsumer</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">,</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$newInstance(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.V)))/__typeArg_K">__typeArg_K</span><span class="symbol">:</span>&nbsp;<span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$newInstance(io.vertx.kafka.client.consumer.KafkaConsumer((kotlin.Any, )), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.K)), io.vertx.lang.rxjava.TypeArg((io.vertx.rxjava.kafka.client.consumer.KafkaConsumer.newInstance.V)))/__typeArg_V">__typeArg_V</span><span class="symbol">:</span>&nbsp;<span class="identifier">TypeArg</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="offsets-for-times.html">offsetsForTimes</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">offsetsForTimes</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$offsetsForTimes(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((io.vertx.kafka.client.consumer.OffsetAndTimestamp)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$offsetsForTimes(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((io.vertx.kafka.client.consumer.OffsetAndTimestamp)))))/timestamp">timestamp</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$offsetsForTimes(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((io.vertx.kafka.client.consumer.OffsetAndTimestamp)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">OffsetAndTimestamp</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Look up the offset for the given partition by timestamp. Note: the result might be null in case for the given timestamp no offset can be found -- e.g., when the timestamp refers to the future</p>
</td>
</tr>
<tr>
<td>
<p><a href="partitions-assigned-handler.html">partitionsAssignedHandler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">partitionsAssignedHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$partitionsAssignedHandler(io.vertx.core.Handler((kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Set the handler called when topic partitions are assigned to the consumer</p>
</td>
</tr>
<tr>
<td>
<p><a href="partitions-for.html">partitionsFor</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">partitionsFor</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$partitionsFor(kotlin.String, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.collections.MutableList((io.vertx.kafka.client.common.PartitionInfo)))))))/topic">topic</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$partitionsFor(kotlin.String, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.collections.MutableList((io.vertx.kafka.client.common.PartitionInfo)))))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html"><span class="identifier">MutableList</span></a><span class="symbol">&lt;</span><span class="identifier">PartitionInfo</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Get metadata about the partitions for a given topic.</p>
</td>
</tr>
<tr>
<td>
<p><a href="partitions-revoked-handler.html">partitionsRevokedHandler</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">partitionsRevokedHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$partitionsRevokedHandler(io.vertx.core.Handler((kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Set the handler called when topic partitions are revoked to the consumer</p>
</td>
</tr>
<tr>
<td>
<p><a href="pause.html">pause</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partition.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partitions.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partition. 
<p> Due to internal buffering of messages, the will continue to observe messages from the given <code>topicParation</code> until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will not see messages from the given <code>topicParation</code>.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pause(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages from the given <code>topicParations</code> until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will not see messages from the given <code>topicParations</code>.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="paused.html">paused</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">paused</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$paused(io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Get the set of partitions that were previously paused by a call to pause(Set).</p>
</td>
</tr>
<tr>
<td>
<p><a href="poll-timeout.html">pollTimeout</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">pollTimeout</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$pollTimeout(kotlin.Long)/timeout">timeout</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Sets the poll timeout (in ms) for the underlying native Kafka Consumer. Defaults to 1000. Setting timeout to a lower value results in a more 'responsive' client, because it will block for a shorter period if no data is available in the assigned partition and therefore allows subsequent actions to be executed with a shorter delay. At the same time, the client will poll more frequently and thus will potentially create a higher load on the Kafka Broker.</p>
</td>
</tr>
<tr>
<td>
<p><a href="position.html">position</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">position</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$position(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/partition">partition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$position(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.Long)))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Get the offset of the next record that will be fetched (if a record with that offset exists).</p>
</td>
</tr>
<tr>
<td>
<p><a href="resume.html">resume</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Resume specified partition which have been paused with pause.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$resume(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Resume specified partitions which have been paused with pause.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-assign.html">rxAssign</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxAssign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxAssign(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Manually assign a partition to this consumer. 
<p> Due to internal buffering of messages, when reassigning the old partition may remain in effect (as observed by the record handler)} until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new partition.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxAssign</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxAssign(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Manually assign a list of partition to this consumer. 
<p> Due to internal buffering of messages, when reassigning the old set of partitions may remain in effect (as observed by the record handler)} until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new set of partitions.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-assignment.html">rxAssignment</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxAssignment</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Get the set of partitions currently assigned to this consumer.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-beginning-offsets.html">rxBeginningOffsets</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxBeginningOffsets</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxBeginningOffsets(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span></code>
<p>Get the first offset for the given partitions.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-close.html">rxClose</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxClose</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Close the consumer</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-commit.html">rxCommit</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxCommit</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Commit current offsets for all the subscribed list of topics and partition.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-committed.html">rxCommitted</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxCommitted</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxCommitted(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">OffsetAndMetadata</span><span class="symbol">&gt;</span></code>
<p>Get the last committed offset for the given partition (whether the commit happened by this process or another).</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-end-offsets.html">rxEndOffsets</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxEndOffsets</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxEndOffsets(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span></code>
<p>Get the last offset for the given partition. The last offset of a partition is the offset of the upcoming message, i.e. the offset of the last available message + 1.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-offsets-for-times.html">rxOffsetsForTimes</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxOffsetsForTimes</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxOffsetsForTimes(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxOffsetsForTimes(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/timestamp">timestamp</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">OffsetAndTimestamp</span><span class="symbol">&gt;</span></code>
<p>Look up the offset for the given partition by timestamp. Note: the result might be null in case for the given timestamp no offset can be found -- e.g., when the timestamp refers to the future</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-partitions-for.html">rxPartitionsFor</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxPartitionsFor</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxPartitionsFor(kotlin.String)/topic">topic</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html"><span class="identifier">MutableList</span></a><span class="symbol">&lt;</span><span class="identifier">PartitionInfo</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Get metadata about the partitions for a given topic.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-pause.html">rxPause</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxPause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxPause(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partition. 
<p> Due to internal buffering of messages, the will continue to observe messages from the given <code>topicParation</code> until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will not see messages from the given <code>topicParation</code>.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxPause</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxPause(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Suspend fetching from the requested partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages from the given <code>topicParations</code> until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will not see messages from the given <code>topicParations</code>.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-paused.html">rxPaused</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxPaused</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Get the set of partitions that were previously paused by a call to pause(Set).</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-position.html">rxPosition</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxPosition</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxPosition(io.vertx.kafka.client.common.TopicPartition)/partition">partition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span></code>
<p>Get the offset of the next record that will be fetched (if a record with that offset exists).</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-resume.html">rxResume</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxResume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxResume(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Resume specified partition which have been paused with pause.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxResume</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxResume(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Resume specified partitions which have been paused with pause.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-seek.html">rxSeek</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSeek</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Overrides the fetch offsets that the consumer will use on the next poll. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-seek-to-beginning.html">rxSeekToBeginning</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSeekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeekToBeginning(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partition. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSeekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeekToBeginning(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-seek-to-end.html">rxSeekToEnd</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSeekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeekToEnd(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partition. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSeekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSeekToEnd(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-subscribe.html">rxSubscribe</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSubscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSubscribe(kotlin.String)/topic">topic</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given topic to get dynamically assigned partitions. 
<p> Due to internal buffering of messages, when changing the subscribed topic the old topic may remain in effect (as observed by the record handler}) until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new topic.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSubscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$rxSubscribe(kotlin.collections.MutableSet((kotlin.String)))/topics">topics</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given list of topics to get dynamically assigned partitions. 
<p> Due to internal buffering of messages, when changing the subscribed topics the old set of topics may remain in effect (as observed by the record handler}) until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new set of topics.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-subscription.html">rxSubscription</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxSubscription</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Get the current subscription.</p>
</td>
</tr>
<tr>
<td>
<p><a href="rx-unsubscribe.html">rxUnsubscribe</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">rxUnsubscribe</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Single.html"><span class="identifier">Single</span></a><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span></code>
<p>Unsubscribe from topics currently subscribed with subscribe.</p>
</td>
</tr>
<tr>
<td>
<p><a href="seek.html">seek</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seek</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Overrides the fetch offsets that the consumer will use on the next poll.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seek</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/offset">offset</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seek(io.vertx.kafka.client.common.TopicPartition, kotlin.Long, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Overrides the fetch offsets that the consumer will use on the next poll. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="seek-to-beginning.html">seekToBeginning</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partition.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partitions.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partition. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToBeginning</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToBeginning(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the first offset for each of the given partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="seek-to-end.html">seekToEnd</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(io.vertx.kafka.client.common.TopicPartition)/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partition.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partitions.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartition">topicPartition</span><span class="symbol">:</span>&nbsp;<span class="identifier">TopicPartition</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(io.vertx.kafka.client.common.TopicPartition, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partition. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">seekToEnd</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topicPartitions">topicPartitions</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><span class="identifier">TopicPartition</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$seekToEnd(kotlin.collections.MutableSet((io.vertx.kafka.client.common.TopicPartition)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Seek to the last offset for each of the given partitions. 
<p> Due to internal buffering of messages, the will continue to observe messages fetched with respect to the old offset until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new offset.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="subscribe.html">subscribe</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">subscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.String)/topic">topic</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given topic to get dynamically assigned partitions.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">subscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.collections.MutableSet((kotlin.String)))/topics">topics</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given list of topics to get dynamically assigned partitions.</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">subscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.String, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topic">topic</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.String, io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given topic to get dynamically assigned partitions. 
<p> Due to internal buffering of messages, when changing the subscribed topic the old topic may remain in effect (as observed by the record handler}) until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new topic.</p>
</p>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">subscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.collections.MutableSet((kotlin.String)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/topics">topics</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscribe(kotlin.collections.MutableSet((kotlin.String)), io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Subscribe to the given list of topics to get dynamically assigned partitions. 
<p> Due to internal buffering of messages, when changing the subscribed topics the old set of topics may remain in effect (as observed by the record handler}) until some time <em>after</em> the given <code>completionHandler</code> is called. In contrast, the once the given <code>completionHandler</code> is called the <code><a href="#">io.vertx.rxjava.kafka.client.consumer.KafkaConsumer#batchHandler</a></code> will only see messages consistent with the new set of topics.</p>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="subscription.html">subscription</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">subscription</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$subscription(io.vertx.core.Handler((io.vertx.core.AsyncResult((kotlin.collections.MutableSet((kotlin.String)))))))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html"><span class="identifier">MutableSet</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Get the current subscription.</p>
</td>
</tr>
<tr>
<td>
<p><a href="to-observable.html">toObservable</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">toObservable</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Observable.html"><span class="identifier">Observable</span></a><span class="symbol">&lt;</span><span class="identifier">KafkaConsumerRecord</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="to-string.html">toString</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">toString</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="unsubscribe.html">unsubscribe</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">unsubscribe</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">unsubscribe</span><span class="symbol">(</span><span class="identifier" id="io.vertx.rxjava.kafka.client.consumer.KafkaConsumer$unsubscribe(io.vertx.core.Handler((io.vertx.core.AsyncResult((java.lang.Void)))))/completionHandler">completionHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">AsyncResult</span><span class="symbol">&lt;</span><span class="identifier">Void</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span></code>
<p>Unsubscribe from topics currently subscribed with subscribe.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
