<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vert.x Kafka client - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="http://vertx.io/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="http://vertx.io/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="http://vertx.io/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="http://vertx.io/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="http://vertx.io/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="http://vertx.io/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="http://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="http://vertx.io/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="http://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="http://vertx.io/" class="navbar-brand"><img alt="Brand" src="http://vertx.io/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://vertx.io/download/">Download</a></li>
        <li><a href="http://vertx.io/docs/3.4.2/">Documentation</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
        <li><a href="http://vertx.io/community/">Community</a></li>
        <li><a href="http://vertx.io/materials/">Materials</a></li>
        <li><a href="http://vertx.io/blog/">Blog</a></li>        
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Vert.x Kafka client</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_using_the_vert_x_kafka_client">Using the Vert.x Kafka client</a></li>
<li><a href="#_creating_kafka_clients">Creating Kafka clients</a></li>
<li><a href="#_receiving_messages_from_a_topic_joining_a_consumer_group">Receiving messages from a topic joining a consumer group</a></li>
<li><a href="#_receiving_messages_from_a_topic_requesting_specific_partitions">Receiving messages from a topic requesting specific partitions</a></li>
<li><a href="#_getting_topic_partition_information">Getting topic partition information</a></li>
<li><a href="#_manual_offset_commit">Manual offset commit</a></li>
<li><a href="#_seeking_in_a_topic_partition">Seeking in a topic partition</a></li>
<li><a href="#_offset_lookup">Offset lookup</a></li>
<li><a href="#_message_flow_control">Message flow control</a></li>
<li><a href="#_closing_a_consumer">Closing a consumer</a></li>
<li><a href="#_sending_messages_to_a_topic">Sending messages to a topic</a></li>
<li><a href="#_sharing_a_producer">Sharing a producer</a></li>
<li><a href="#_closing_a_producer">Closing a producer</a></li>
<li><a href="#_getting_topic_partition_information_2">Getting topic partition information</a></li>
<li><a href="#_handling_errors">Handling errors</a></li>
<li><a href="#_automatic_clean_up_in_verticles">Automatic clean-up in verticles</a></li>
<li><a href="#_using_vert_x_serializers_deserizaliers">Using Vert.x serializers/deserizaliers</a></li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_using_the_vert_x_kafka_client">Using the Vert.x Kafka client</a></li>
<li><a href="#_creating_kafka_clients">Creating Kafka clients</a></li>
<li><a href="#_receiving_messages_from_a_topic_joining_a_consumer_group">Receiving messages from a topic joining a consumer group</a></li>
<li><a href="#_receiving_messages_from_a_topic_requesting_specific_partitions">Receiving messages from a topic requesting specific partitions</a></li>
<li><a href="#_getting_topic_partition_information">Getting topic partition information</a></li>
<li><a href="#_manual_offset_commit">Manual offset commit</a></li>
<li><a href="#_seeking_in_a_topic_partition">Seeking in a topic partition</a></li>
<li><a href="#_offset_lookup">Offset lookup</a></li>
<li><a href="#_message_flow_control">Message flow control</a></li>
<li><a href="#_closing_a_consumer">Closing a consumer</a></li>
<li><a href="#_sending_messages_to_a_topic">Sending messages to a topic</a></li>
<li><a href="#_sharing_a_producer">Sharing a producer</a></li>
<li><a href="#_closing_a_producer">Closing a producer</a></li>
<li><a href="#_getting_topic_partition_information_2">Getting topic partition information</a></li>
<li><a href="#_handling_errors">Handling errors</a></li>
<li><a href="#_automatic_clean_up_in_verticles">Automatic clean-up in verticles</a></li>
<li><a href="#_using_vert_x_serializers_deserizaliers">Using Vert.x serializers/deserizaliers</a></li>
</ul>
        </div>
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This component provides a Kafka client for reading and sending messages from/to an <a href="https://kafka.apache.org/">Apache Kafka</a> cluster.</p>
</div>
<div class="paragraph">
<p>As consumer, the API provides methods for subscribing to a topic partition receiving
messages asynchronously or reading them as a stream (even with the possibility to pause/resume the stream).</p>
</div>
<div class="paragraph">
<p>As producer, the API provides methods for sending message to a topic partition like writing on a stream.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
this module has the tech preview status, this means the API can change between versions.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_vert_x_kafka_client">Using the Vert.x Kafka client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use this component, add the following dependency to the dependencies section of your build descriptor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (in your <code>pom.xml</code>):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>io.vertx<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>vertx-kafka-client<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>3.4.2<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (in your <code>build.gradle</code> file):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compile io.vertx:vertx-kafka-<span class="key">client</span>:<span class="float">3.4</span><span class="float">.2</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_kafka_clients">Creating Kafka clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creating consumers and producers is quite similar and on how it works using the native Kafka client library.</p>
</div>
<div class="paragraph">
<p>They need to be configured with a bunch of properties as described in the official
Apache Kafka documentation, for the <a href="https://kafka.apache.org/documentation/#newconsumerconfigs">consumer</a> and
for the <a href="https://kafka.apache.org/documentation/#producerconfigs">producer</a>.</p>
</div>
<div class="paragraph">
<p>To achieve that, a map can be configured with such properties passing it to one of the
static creation methods exposed by <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> and
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html">KafkaProducer</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// creating the consumer using map config
var config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.deserializer&quot; -&gt; &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)
config + (&quot;value.deserializer&quot; -&gt; &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)
config + (&quot;group.id&quot; -&gt; &quot;my_group&quot;)
config + (&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;)
config + (&quot;enable.auto.commit&quot; -&gt; &quot;false&quot;)

// use consumer for interacting with Apache Kafka
var consumer = KafkaConsumer.create(vertx, config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, a <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> instance is created using
a map instance in order to specify the Kafka nodes list to connect (just one) and
the deserializers to use for getting key and value from each received message.</p>
</div>
<div class="paragraph">
<p>Likewise a producer can be created</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// creating the producer using map and class types for key and value serializers/deserializers
var config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.serializer&quot; -&gt; &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)
config + (&quot;value.serializer&quot; -&gt; &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)
config + (&quot;acks&quot; -&gt; &quot;1&quot;)

// use producer for interacting with Apache Kafka
var producer = KafkaProducer.create(vertx, config)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receiving_messages_from_a_topic_joining_a_consumer_group">Receiving messages from a topic joining a consumer group</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In order to start receiving messages from Kafka topics, the consumer can use the
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(java.util.Set)">subscribe</a></code> method for
subscribing to a set of topics being part of a consumer group (specified by the properties on creation).</p>
</div>
<div class="paragraph">
<p>You also need to register a handler for handling incoming messages using the
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#handler(io.vertx.core.Handler)">handler</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s&quot;Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}&quot;)
})

// subscribe to several topics
var topics = new java.util.HashSet()
topics.add(&quot;topic1&quot;)
topics.add(&quot;topic2&quot;)
topics.add(&quot;topic3&quot;)
consumer.subscribe(topics)

// or just subscribe to a single topic
consumer.subscribe(&quot;a-single-topic&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The handler can be registered before or after the call to <code>subscribe()</code>; messages won&#8217;t be consumed until both
methods have been called. This allows you to call <code>subscribe()</code>, then <code>seek()</code> and finally <code>handler()</code> in
order to only consume messages starting from a particular offset, for example.</p>
</div>
<div class="paragraph">
<p>A handler can also be passed during subscription to be aware of the subscription result and being notified when the operation
is completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s&quot;Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}&quot;)
})

// subscribe to several topics
var topics = new java.util.HashSet()
topics.add(&quot;topic1&quot;)
topics.add(&quot;topic2&quot;)
topics.add(&quot;topic3&quot;)
consumer.subscribeFuture(topics).onComplete{
  case Success(result) =&gt; {
    println(&quot;subscribed&quot;)
  }
  case Failure(cause) =&gt; {
    println(s&quot;$cause&quot;)
  }
}

// or just subscribe to a single topic
consumer.subscribeFuture(&quot;a-single-topic&quot;).onComplete{
  case Success(result) =&gt; {
    println(&quot;subscribed&quot;)
  }
  case Failure(cause) =&gt; {
    println(s&quot;$cause&quot;)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the consumer group way, the Kafka cluster assigns partitions to the consumer taking into account other connected
consumers in the same consumer group, so that partitions can be spread across them.</p>
</div>
<div class="paragraph">
<p>The Kafka cluster handles partitions re-balancing when a consumer leaves the group (so assigned partitions are free
to be assigned to other consumers) or a new consumer joins the group (so it wants partitions to read from).</p>
</div>
<div class="paragraph">
<p>You can register handlers on a <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> to be notified
of the partitions revocations and assignments by the Kafka cluster using
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsRevokedHandler(io.vertx.core.Handler)">partitionsRevokedHandler</a></code> and
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsAssignedHandler(io.vertx.core.Handler)">partitionsAssignedHandler</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s&quot;Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}&quot;)
})

// registering handlers for assigned and revoked partitions
consumer.partitionsAssignedHandler((topicPartitions: java.util.Set&lt;io.vertx.scala.kafka.client.common.TopicPartition&gt;) =&gt; {

  println(&quot;Partitions assigned&quot;)
  topicPartitions.foreach(topicPartition =&gt; {
    println(s&quot;${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}&quot;)
  })

})

consumer.partitionsRevokedHandler((topicPartitions: java.util.Set&lt;io.vertx.scala.kafka.client.common.TopicPartition&gt;) =&gt; {

  println(&quot;Partitions revoked&quot;)
  topicPartitions.foreach(topicPartition =&gt; {
    println(s&quot;${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}&quot;)
  })

})

// subscribes to the topic
consumer.subscribeFuture(&quot;test&quot;).onComplete{
  case Success(result) =&gt; {
    println(&quot;Consumer subscribed&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After joining a consumer group for receiving messages, a consumer can decide to leave the consumer group in order to
not get messages anymore using <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#unsubscribe()">unsubscribe</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// consumer is already member of a consumer group

// unsubscribing request
consumer.unsubscribe()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add an handler to be notified of the result</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// consumer is already member of a consumer group

// unsubscribing request
consumer.unsubscribeFuture().onComplete{
  case Success(result) =&gt; {
    println(&quot;Consumer unsubscribed&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receiving_messages_from_a_topic_requesting_specific_partitions">Receiving messages from a topic requesting specific partitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Besides being part of a consumer group for receiving messages from a topic, a consumer can ask for a specific
topic partition. When the consumer is not part part of a consumer group the overall application cannot
rely on the re-balancing feature.</p>
</div>
<div class="paragraph">
<p>You can use <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(java.util.Set,%20io.vertx.core.Handler)">assign</a></code>
in order to ask for specific partitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s&quot;key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}&quot;)
})

//
var topicPartitions = new java.util.HashSet()
topicPartitions.add(TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)
)

// requesting to be assigned the specific partition
consumer.assignFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    println(&quot;Partition assigned&quot;)

    // requesting the assigned partitions
    consumer.assignmentFuture().onComplete{
      case Success(result) =&gt; {

        result.foreach(topicPartition =&gt; {
          println(s&quot;${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}&quot;)
        })

      }
      case Failure(cause) =&gt; println(&quot;Failure&quot;)
    }
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>subscribe()</code>, the handler can be registered before or after the call to <code>assign()</code>;
messages won&#8217;t be consumed until both methods have been called. This allows you to call
<code>assign()</code>, then <code>seek()</code> and finally <code>handler()</code> in
order to only consume messages starting from a particular offset, for example.</p>
</div>
<div class="paragraph">
<p>Calling <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignment(io.vertx.core.Handler)">assignment</a></code> provides
the list of the current assigned partitions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_topic_partition_information">Getting topic partition information</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can call the <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsFor(java.lang.String,%20io.vertx.core.Handler)">partitionsFor</a></code> to get information about
partitions for a specified topic</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// asking partitions information about specific topic
consumer.partitionsForFuture(&quot;test&quot;).onComplete{
  case Success(result) =&gt; {

    result.foreach(partitionInfo =&gt; {
      println(partitionInfo)
    })

  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#listTopics(io.vertx.core.Handler)">listTopics</a></code> provides all available topics
with related partitions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// asking information about available topics and related partitions
consumer.listTopicsFuture().onComplete{
  case Success(result) =&gt; {

    var map = result
    map.foreach{
      case (topic: java.lang.String, partitions: java.util.List&lt;io.vertx.scala.kafka.client.common.PartitionInfo&gt;) =&gt; {
      println(s&quot;topic = ${topic}&quot;)
      println(s&quot;partitions = ${map(topic)}&quot;)
    }}
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_manual_offset_commit">Manual offset commit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Apache Kafka the consumer is in charge to handle the offset of the last read message.</p>
</div>
<div class="paragraph">
<p>This is executed by the commit operation executed automatically every time a bunch of messages are read
from a topic partition. The configuration parameter <code>enable.auto.commit</code> must be set to <code>true</code> when the
consumer is created.</p>
</div>
<div class="paragraph">
<p>Manual offset commit, can be achieved with <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#commit(io.vertx.core.Handler)">commit</a></code>.
It can be used to achieve <em>at least once</em> delivery to be sure that the read messages are processed before committing
the offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// consumer is processing read messages

// committing offset of the last read message
consumer.commitFuture().onComplete{
  case Success(result) =&gt; {
    println(&quot;Last read message offset committed&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_seeking_in_a_topic_partition">Seeking in a topic partition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apache Kafka can retain messages for a long period of time and the consumer can seek inside a topic partition
and obtain arbitrary access to the messages.</p>
</div>
<div class="paragraph">
<p>You can use <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seek(io.vertx.kafka.client.common.TopicPartition,%20long)">seek</a></code> to change the offset for reading at a specific
position</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)


// seek to a specific offset
consumer.seekFuture(topicPartition, 10).onComplete{
  case Success(result) =&gt; {
    println(&quot;Seeking done&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the consumer needs to re-read the stream from the beginning, it can use <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(io.vertx.kafka.client.common.TopicPartition)">seekToBeginning</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)


// seek to the beginning of the partition
consumer.seekToBeginningFuture(java.util.Collections.singleton(topicPartition)).onComplete{
  case Success(result) =&gt; {
    println(&quot;Seeking done&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(io.vertx.kafka.client.common.TopicPartition)">seekToEnd</a></code> can be used to come back at the end of the partition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)


// seek to the end of the partition
consumer.seekToEndFuture(java.util.Collections.singleton(topicPartition)).onComplete{
  case Success(result) =&gt; {
    println(&quot;Seeking done&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_offset_lookup">Offset lookup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use the beginningOffsets API introduced in Kafka 0.10.1.1 to get the first offset
for a given partition. In contrast to <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(io.vertx.kafka.client.common.TopicPartition)">seekToBeginning</a></code>,
it does not change the consumer&#8217;s offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartitions = new java.util.HashSet()
var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)

topicPartitions.add(topicPartition)

consumer.beginningOffsetsFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    var results = result
    results.foreach{
      case (topic: io.vertx.scala.kafka.client.common.TopicPartition, beginningOffset: java.lang.Long) =&gt; {
      println(s&quot;Beginning offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, beginningOffset=${beginningOffset}&quot;)
    }}
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}

// Convenience method for single-partition lookup
consumer.beginningOffsetsFuture(topicPartition).onComplete{
  case Success(result) =&gt; {
    var beginningOffset = result
    println(s&quot;Beginning offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, beginningOffset=${beginningOffset}&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the endOffsets API introduced in Kafka 0.10.1.1 to get the last offset
for a given partition. In contrast to <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(io.vertx.kafka.client.common.TopicPartition)">seekToEnd</a></code>,
it does not change the consumer&#8217;s offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartitions = new java.util.HashSet()
var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)

topicPartitions.add(topicPartition)

consumer.endOffsetsFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    var results = result
    results.foreach{
      case (topic: io.vertx.scala.kafka.client.common.TopicPartition, endOffset: java.lang.Long) =&gt; {
      println(s&quot;End offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, endOffset=${endOffset}&quot;)
    }}
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}

// Convenience method for single-partition lookup
consumer.endOffsetsFuture(topicPartition).onComplete{
  case Success(result) =&gt; {
    var endOffset = result
    println(s&quot;End offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, endOffset=${endOffset}&quot;)
  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the offsetsForTimes API introduced in Kafka 0.10.1.1 to look up an offset by
timestamp, i.e. search parameter is an epoch timestamp and the call returns the lowest offset
with ingestion timestamp &gt;= given timestamp.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">Code not translatable</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_message_flow_control">Message flow control</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A consumer can control the incoming message flow and pause/resume the read operation from a topic, e.g it
can pause the message flow when it needs more time to process the actual messages and then resume
to continue message processing.</p>
</div>
<div class="paragraph">
<p>To achieve that you can use <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause()">pause</a></code> and
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume()">resume</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">var topicPartition = TopicPartition()
  .setTopic(&quot;test&quot;)
  .setPartition(0)


// registering the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s&quot;key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}&quot;)

  // i.e. pause/resume on partition 0, after reading message up to offset 5
  if ((record.partition() == 0) &amp;&amp; (record.offset() == 5)) {

    // pause the read operations
    consumer.pauseFuture(topicPartition).onComplete{
      case Success(result) =&gt; {

        println(&quot;Paused&quot;)

        // resume read operation after a specific time
        vertx.setTimer(5000, (timeId: java.lang.Long) =&gt; {

          // resumi read operations
          consumer.resume(topicPartition)
        })
      }
      case Failure(cause) =&gt; println(&quot;Failure&quot;)
    }
  }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closing_a_consumer">Closing a consumer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Call close to close the consumer. Closing the consumer closes any open connections and releases all consumer resources.</p>
</div>
<div class="paragraph">
<p>The close is actually asynchronous and might not complete until some time after the call has returned. If you want to be notified
when the actual close has completed then you can pass in a handler.</p>
</div>
<div class="paragraph">
<p>This handler will then be called when the close has fully completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">consumer.closeFuture().onComplete{
  case Success(result) =&gt; {
    println(&quot;Consumer is now closed&quot;)
  }
  case Failure(cause) =&gt; {
    println(s&quot;$cause&quot;)
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sending_messages_to_a_topic">Sending messages to a topic</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use  <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#write(io.vertx.kafka.client.producer.KafkaProducerRecord)">write</a></code> to send messages (records) to a topic.</p>
</div>
<div class="paragraph">
<p>The simplest way to send a message is to specify only the destination topic and the related value, omitting its key
or partition, in this case the messages are sent in a round robin fashion across all the partitions of the topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">for ( i &lt;- 0 until 5) {

  // only topic and message value are specified, round robin on destination partitions
  var record = KafkaProducerRecord.create(&quot;test&quot;, s&quot;message_${i}&quot;)

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can receive message sent metadata like its topic, its destination partition and its assigned offset.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">for ( i &lt;- 0 until 5) {

  // only topic and message value are specified, round robin on destination partitions
  var record = KafkaProducerRecord.create(&quot;test&quot;, s&quot;message_${i}&quot;)

  producer.writeFuture(record).onComplete{
    case Success(result) =&gt; {

      var recordMetadata = result
      println(s&quot;Message ${record.value()} written on topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, offset=${todo-renderDataObjectMemberSelect}&quot;)
    }
    case Failure(cause) =&gt; println(&quot;Failure&quot;)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you need to assign a partition to a message, you can specify its partition identifier
or its key</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">for ( i &lt;- 0 until 10) {

  // a destination partition is specified
  var record = KafkaProducerRecord.create(&quot;test&quot;, null, s&quot;message_${i}&quot;, 0)

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the producers identifies the destination using key hashing, you can use that to guarantee that all
messages with the same key are sent to the same partition and retain the order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">for ( i &lt;- 0 until 10) {

  // i.e. defining different keys for odd and even messages
  var key = i % 2

  // a key is specified, all messages with same key will be sent to the same partition
  var record = KafkaProducerRecord.create(&quot;test&quot;, java.lang.String.valueOf(key), s&quot;message_${i}&quot;)

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the shared producer is created on the first <code>createShared</code> call and its configuration is defined at this moment,
shared producer usage must use the same configuration.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sharing_a_producer">Sharing a producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you want to share the same producer from within several verticles or contexts.</p>
</div>
<div class="paragraph">
<p>Calling <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#createShared(io.vertx.core.Vertx,%20java.lang.String,%20java.util.Map)">KafkaProducer.createShared</a></code>
returns a producer that can be shared safely.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// Create a shared producer identified by 'the-producer'
var producer1 = KafkaProducer.createShared(vertx, &quot;the-producer&quot;, config)

// Sometimes later you can close it
producer1.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same resources (thread, connection) will be shared between the producer returned by this method.</p>
</div>
<div class="paragraph">
<p>When you are done with the producer, just close it, when all shared producers are closed, the resources will
be released for you.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closing_a_producer">Closing a producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Call close to close the producer. Closing the producer closes any open connections and releases all producer resources.</p>
</div>
<div class="paragraph">
<p>The close is actually asynchronous and might not complete until some time after the call has returned. If you want to be notified
when the actual close has completed then you can pass in a handler.</p>
</div>
<div class="paragraph">
<p>This handler will then be called when the close has fully completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">producer.closeFuture().onComplete{
  case Success(result) =&gt; {
    println(&quot;Producer is now closed&quot;)
  }
  case Failure(cause) =&gt; {
    println(s&quot;$cause&quot;)
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_topic_partition_information_2">Getting topic partition information</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can call the <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#partitionsFor(java.lang.String,%20io.vertx.core.Handler)">partitionsFor</a></code> to get information about
partitions for a specified topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// asking partitions information about specific topic
producer.partitionsForFuture(&quot;test&quot;).onComplete{
  case Success(result) =&gt; {

    result.foreach(partitionInfo =&gt; {
      println(partitionInfo)
    })

  }
  case Failure(cause) =&gt; println(&quot;Failure&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_errors">Handling errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Errors handling (e.g timeout) between a Kafka client (consumer or producer) and the Kafka cluster is done using
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code> or
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// setting handler for errors
consumer.exceptionHandler((e: java.lang.Throwable) =&gt; {
  println(s&quot;Error = ${e.getMessage()}&quot;)
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_automatic_clean_up_in_verticles">Automatic clean-up in verticles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you’re creating consumers and producer from inside verticles, those consumers and producers will be automatically
closed when the verticle is undeployed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_vert_x_serializers_deserizaliers">Using Vert.x serializers/deserizaliers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Kafka client comes out of the box with serializers and deserializers for buffers, json object
and json array.</p>
</div>
<div class="paragraph">
<p>In a consumer you can use buffers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// Creating a consumer able to deserialize to buffers
var config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.BufferDeserializer&quot;)
config + (&quot;value.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.BufferDeserializer&quot;)
config + (&quot;group.id&quot; -&gt; &quot;my_group&quot;)
config + (&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;)
config + (&quot;enable.auto.commit&quot; -&gt; &quot;false&quot;)

// Creating a consumer able to deserialize to json object
config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonObjectDeserializer&quot;)
config + (&quot;value.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonObjectDeserializer&quot;)
config + (&quot;group.id&quot; -&gt; &quot;my_group&quot;)
config + (&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;)
config + (&quot;enable.auto.commit&quot; -&gt; &quot;false&quot;)

// Creating a consumer able to deserialize to json array
config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonArrayDeserializer&quot;)
config + (&quot;value.deserializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonArrayDeserializer&quot;)
config + (&quot;group.id&quot; -&gt; &quot;my_group&quot;)
config + (&quot;auto.offset.reset&quot; -&gt; &quot;earliest&quot;)
config + (&quot;enable.auto.commit&quot; -&gt; &quot;false&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or in a producer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="scala">// Creating a producer able to serialize to buffers
var config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.BufferSerializer&quot;)
config + (&quot;value.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.BufferSerializer&quot;)
config + (&quot;acks&quot; -&gt; &quot;1&quot;)

// Creating a producer able to serialize to json object
config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonObjectSerializer&quot;)
config + (&quot;value.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonObjectSerializer&quot;)
config + (&quot;acks&quot; -&gt; &quot;1&quot;)

// Creating a producer able to serialize to json array
config = Map()
config + (&quot;bootstrap.servers&quot; -&gt; &quot;localhost:9092&quot;)
config + (&quot;key.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonArraySerializer&quot;)
config + (&quot;value.serializer&quot; -&gt; &quot;io.vertx.kafka.client.serialization.JsonArraySerializer&quot;)
config + (&quot;acks&quot; -&gt; &quot;1&quot;)</code></pre>
</div>
</div>
</div>
</div>

        

        
          <div id="footer">
            <div id="footer-text">
              
                Last updated 2017-06-14 22:22:38 CEST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="http://vertx.io/">Home</a></li>
          <li><a href="http://vertx.io/download/">Download</a></li>
          <li><a href="http://vertx.io/docs/3.4.2/">Documentation</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
          <li><a href="http://vertx.io/blog/">Blog</a></li>
          <li><a href="http://vertx.io/vertx2/" class="vertx-2-link">Vert.x 2</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="http://vertx.io/community/">Help &amp; Contributors</a></li>
          <li><a href="http://vertx.io/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual licensed under the <a href="https://www.eclipse.org/org/documents/epl-v10.php">Eclipse Public License 1.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="http://vertx.io/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="http://vertx.io/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="http://vertx.io/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script>
<script src="http://vertx.io/javascripts/bootstrap.min.js"></script>
<script src="http://vertx.io/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="http://vertx.io/javascripts/sidebar.js"></script>


</body>
</html>

