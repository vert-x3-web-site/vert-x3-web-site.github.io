<!DOCTYPE html>
<html lang="en">
<head>
  <title>vertx-lang-kotlin-coroutines - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="http://vertx.io/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="http://vertx.io/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="http://vertx.io/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="http://vertx.io/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="http://vertx.io/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="http://vertx.io/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="http://vertx.io/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="http://vertx.io/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="http://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="http://vertx.io/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="http://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="http://vertx.io/" class="navbar-brand"><img alt="Brand" src="http://vertx.io/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="http://vertx.io/download/">Download</a></li>
        <li><a href="http://vertx.io/docs/3.5.0/">Documentation</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
        <li><a href="http://vertx.io/community/">Community</a></li>
        <li><a href="http://vertx.io/materials/">Materials</a></li>
        <li><a href="http://vertx.io/blog/">Blog</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>vertx-lang-kotlin-coroutines</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_running_a_coroutine_from_a_vert_x_context">Running a coroutine from a Vert.x context</a></li>
<li><a href="#_extending_coroutineverticle">Extending CoroutineVerticle</a></li>
<li><a href="#_getting_one_shot_asynchronous_results">Getting one-shot asynchronous results</a></li>
<li><a href="#_getting_one_shot_events">Getting one-shot events</a></li>
<li><a href="#_streams_of_events">Streams of events</a></li>
<li><a href="#_handlers">Handlers</a></li>
<li><a href="#_awaiting_the_completion_of_vert_x_futures">Awaiting the completion of Vert.x futures</a></li>
<li><a href="#_channels">Channels</a>
<ul class="sectlevel2">
<li><a href="#_receiving_data">Receiving data</a></li>
<li><a href="#_sending_data">Sending data</a></li>
</ul>
</li>
<li><a href="#_rxjava_integration">RxJava integration</a></li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_running_a_coroutine_from_a_vert_x_context">Running a coroutine from a Vert.x context</a></li>
<li><a href="#_extending_coroutineverticle">Extending CoroutineVerticle</a></li>
<li><a href="#_getting_one_shot_asynchronous_results">Getting one-shot asynchronous results</a></li>
<li><a href="#_getting_one_shot_events">Getting one-shot events</a></li>
<li><a href="#_streams_of_events">Streams of events</a></li>
<li><a href="#_handlers">Handlers</a></li>
<li><a href="#_awaiting_the_completion_of_vert_x_futures">Awaiting the completion of Vert.x futures</a></li>
<li><a href="#_channels">Channels</a>
<ul class="sectlevel2">
<li><a href="#_receiving_data">Receiving data</a></li>
<li><a href="#_sending_data">Sending data</a></li>
</ul>
</li>
<li><a href="#_rxjava_integration">RxJava integration</a></li>
</ul>
        </div>
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The <code>vertx-lang-kotlin-coroutines</code> integrates Kotlin <em>coroutines</em> for performing asynchronous operations and processing events.
This results in using a programming model that looks like sequential code, yet it does not block kernel threads.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the key advantages of Vert.x over many legacy application platforms is that it is almost entirely non-blocking
(of kernel threads).
This allows Vert.x-based applications to handle a lot of concurrency (e.g., many connections and messages) using a very small number of kernel threads, which in turns unlocks great scalability.</p>
</div>
<div class="paragraph">
<p>The non-blocking nature of Vert.x leads to asynchronous APIs.
Asynchronous APIs can take various forms including callbacks, promises, fibers or reactive extensions.
Vert.x uses the callback style for the core APIs but it also supports other models like RxJava 1 and 2.</p>
</div>
<div class="paragraph">
<p>In some cases, programming using asynchronous APIs can be more challenging than using a classic / sequential style of code, in
particular with several operations need to be done in sequence.
Also, error propagation is often more complex when using asynchronous APIs.</p>
</div>
<div class="paragraph">
<p><code>vertx-lang-kotlin-coroutines</code> uses <em>coroutines</em>.
Coroutines are very lightweight threads that do not correspond to underlying kernel threads, so that when a <em>coroutine</em> needs to <em>"block</em>" it gets <em>suspended</em> and frees its current kernel thread so that another coroutine can process events.</p>
</div>
<div class="paragraph">
<p><code>vertx-lang-kotlin-coroutines</code> uses <a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a> to implement the Coroutines.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>vertx-lang-kotlin-coroutines</code> currently only works with Kotlin and is an <a href="https://kotlinlang.org/docs/reference/coroutines.html#experimental-status-of-coroutines">experimental</a> feature of Kotlin 1.1
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_a_coroutine_from_a_vert_x_context">Running a coroutine from a Vert.x context</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Having imported <code>io.vertx.kotlin.coroutines.VertxCoroutine</code>, the <code>launch</code> method allows running a block of code as a coroutine that can be suspended:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val vertx = Vertx.vertx()
vertx.deployVerticle(ExampleVerticle())

launch(vertx.dispatcher()) {
  val timerId = awaitEvent&lt;Long&gt; { handler -&gt;
    vertx.setTimer(1000, handler)
  }
  println(&quot;Event fired from timer with id ${timerId}&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>vertx.dispatcher()</code> returns a coroutine dispatcher that runs coroutines using the Vert.x event loop.</p>
</div>
<div class="paragraph">
<p>The <code>awaitEvent</code> function suspends the execution of the coroutine until the timer fires and returns the value that was given to the handler.
More details are given in the next sections on handlers, events and stream of events.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_coroutineverticle">Extending CoroutineVerticle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can deploy your code as instances of <code>io.vertx.kotlin.coroutines.CoroutineVerticle</code>, a specialized type of verticle for Kotlin coroutines.
You should override the <code>start()</code> and (optionally) the <code>stop()</code> methods of the verticle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">class MyVerticle : CoroutineVerticle() {
  suspend override fun start() {
    // ...
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_one_shot_asynchronous_results">Getting one-shot asynchronous results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many asynchronous operations in Vert.x take a <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> as the last argument.
An example would be executing an object retrieval using the Vert.x Mongo client, or sending an event bus message then
awaiting for a reply.</p>
</div>
<div class="paragraph">
<p>This is completion by using the <code>awaitResult</code> method which returns the value or throws an exception.</p>
</div>
<div class="paragraph">
<p>The coroutine is being suspended until the event is being processed, and no kernel thread is being blocked.</p>
</div>
<div class="paragraph">
<p>The method is executed by specifying the asynchronous operation that needs to be executed in the form of a block that
is passed to the handler at run-time.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun awaitResultExample() {
  val consumer = vertx.eventBus().localConsumer&lt;String&gt;(&quot;a.b.c&quot;)
  consumer.handler { message -&gt;
    println(&quot;Consumer received: ${message.body()}&quot;)
    message.reply(&quot;pong&quot;)
  }

  // Send a message and wait for a reply
  val reply = awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;
    vertx.eventBus().send(&quot;a.b.c&quot;, &quot;ping&quot;, h)
  }
  println(&quot;Reply received: ${reply.body()}&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the block produces a failure, the caller can handle it as an exception using the usual exception
<code>try</code>/<code>catch</code> constructs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun awaitResultFailureExample() {
  val consumer = vertx.eventBus().localConsumer&lt;String&gt;(&quot;a.b.c&quot;)
  consumer.handler { message -&gt;
    // The consumer will get a failure
    message.fail(0, &quot;it failed!!!&quot;)
  }

  // Send a message and wait for a reply
  try {
    val reply: Message&lt;String&gt; = awaitResult&lt;Message&lt;String&gt;&gt; { h -&gt;
         vertx.eventBus().send(&quot;a.b.c&quot;, &quot;ping&quot;, h)
       }
  } catch(e: ReplyException) {
    // Handle specific reply exception here
    println(&quot;Reply failure: ${e.message}&quot;)
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_one_shot_events">Getting one-shot events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Processing a one-shot event (and not the next occurrences, if any) is completion using the <code>awaitEvent</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun awaitEventExample() {
  val id = awaitEvent&lt;Long&gt; { h -&gt; vertx.setTimer(2000L, h) }
  println(&quot;This should be fired in 2s by some time with id=$id&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_streams_of_events">Streams of events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In many places in Vert.x APIs, streams of events are processed through handlers.
Examples include event bus message consumers and HTTP server requests.</p>
</div>
<div class="paragraph">
<p>The <code>ReceiveChannelHandler</code> class allows receiving events through the (suspendable) <code>receive</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun streamExample() {
  val adapter = vertx.receiveChannelHandler&lt;Message&lt;Int&gt;&gt;()
  vertx.eventBus().localConsumer&lt;Int&gt;(&quot;a.b.c&quot;).handler(adapter)

  // Send 15 messages
  for (i in 0..15) vertx.eventBus().send(&quot;a.b.c&quot;, i)

  // Receive the first 10 messages
  for (i in 0..10) {
    val message = adapter.receive()
    println(&quot;Received: ${message.body()}&quot;)
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handlers">Handlers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Calling <code>launch</code> allows running Vert.x handlers on a coroutine, as in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">vertx.createHttpServer().requestHandler { req -&gt;
  launch(context.dispatcher()) {
    val timerID = awaitEvent&lt;Long&gt; { h -&gt; vertx.setTimer(2000, h) }
    req.response().end(&quot;Hello, this is timerID $timerID after 2 seconds!&quot;)
  }
}.listen(8081)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_awaiting_the_completion_of_vert_x_futures">Awaiting the completion of Vert.x futures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>await</code> extension method on instances of Vert.x future objects suspend coroutines until they have completed, in which case the method returns the corresponding <code>AsyncResult&lt;T&gt;</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun awaitingFuture() {
  val httpServerFuture = Future.future&lt;HttpServer&gt;()
  vertx.createHttpServer()
    .requestHandler { req -&gt; req.response().end(&quot;Hello!&quot;) }
    .listen(8000, httpServerFuture)

  val httpServer = httpServerFuture.await()
  println(&quot;HTTP server port: ${httpServer.actualPort()}&quot;)

  val result = CompositeFuture.all(httpServerFuture, httpServerFuture).await()
  if (result.succeeded()) {
    println(&quot;The server is now running!&quot;)
  } else {
    result.cause().printStackTrace()
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_channels">Channels</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Channels provide a way to transfer a stream of values, Vert.x <code>ReadStream</code> and <code>WriteStream</code> can be adapted
to channels with the <code>toChannel</code> extension method.</p>
</div>
<div class="paragraph">
<p>These adapters take care of managing the back-pressure and the stream termination</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ReadStream&lt;T&gt;</code> is adapted to a <code>ReceiveChannel&lt;T&gt;</code></p>
</li>
<li>
<p><code>WriteStream&lt;T&gt;</code> is adapted to a <code>SendChannel&lt;T&gt;</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_receiving_data">Receiving data</h3>
<div class="paragraph">
<p>Channel can be really useful when you need to handle a stream of correlated values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun handleTemperatureStream() {
  val stream = vertx.eventBus().consumer&lt;Double&gt;(&quot;temperature&quot;)
  val channel = stream.toChannel(vertx)

  var min = Double.MAX_VALUE
  var max = Double.MIN_VALUE

  // Iterate until the stream is closed
  // Non-blocking
  for (msg in channel) {
    val temperature = msg.body()
    min = Math.min(min, temperature)
    max = Math.max(max, temperature)
  }

  // The stream is now closed
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can also be useful for parsing protocols. We will build a non blocking HTTP request parser to show
the power of channels.</p>
</div>
<div class="paragraph">
<p>We will rely on the <a href="http://vertx.io/docs/3.5.0/apidocs/io/vertx/core/parsetools/RecordParser.html"><code>RecordParser</code></a>
to slice the stream of buffer to a stream of buffer delimited by <code>\r\n</code>.</p>
</div>
<div class="paragraph">
<p>Here is the initial version of the parser, that handles only the HTTP request-line</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val server = vertx.createNetServer().connectHandler { socket -&gt;

  // The record parser provides a stream of buffers delimited by \r\n
  val stream = RecordParser.newDelimited(&quot;\r\n&quot;, socket)

  // Convert the stream to a Kotlin channel
  val channel = stream.toChannel(vertx)

  // Run the coroutine
  launch(vertx.dispatcher()) {

    // Receive the request-line
    // Non-blocking
    val line = channel.receive().toString().split(&quot; &quot;)
    val method = line[0]
    val uri = line[1]

    println(&quot;Received HTTP request ($method, $uri)&quot;)

    // Still need to parse headers and body...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parsing the request-line is as simple as calling <code>receive</code> on the channel.</p>
</div>
<div class="paragraph">
<p>The next step parses HTTP headers by receiving chunks until we get an empty one</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Receive HTTP headers
val headers = HashMap&lt;String, String&gt;()
while (true) {

  // Non-blocking
  val header = channel.receive().toString()

  // Done with parsing headers
  if (header.isEmpty()) {
    break
  }

  val pos = header.indexOf(':')
  headers[header.substring(0, pos).toLowerCase()] = header.substring(pos + 1).trim()
}

println(&quot;Received HTTP request ($method, $uri) with headers ${headers.keys}&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally we terminate the parser by handling optional request bodies</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Receive the request body
val transferEncoding = headers[&quot;transfer-encoding&quot;]
val contentLength = headers[&quot;content-length&quot;]

val body : Buffer?
if (transferEncoding == &quot;chunked&quot;) {

  // Handle chunked encoding, e.g
  // 5\r\n
  // HELLO\r\n
  // 0\r\n
  // \r\n

  body = Buffer.buffer()
  while (true) {

    // Parse length chunk
    // Non-blocking
    val len = channel.receive().toString().toInt(16)
    if (len == 0) {
      break
    }

    // The stream is flipped to parse a chunk of the exact size
    stream.fixedSizeMode(len + 2)

    // Receive the chunk and append it
    // Non-blocking
    val chunk = channel.receive()
    body.appendBuffer(chunk, 0, chunk.length() - 2)

    // The stream is flipped back to the \r\n delimiter to parse the next chunk
    stream.delimitedMode(&quot;\r\n&quot;)
  }
} else if (contentLength != null) {

  // The stream is flipped to parse a body of the exact size
  stream.fixedSizeMode(contentLength.toInt())

  // Non-blocking
  body = channel.receive()
} else {
  body = null
}

println(&quot;Received HTTP request ($method, $uri) with headers ${headers.keys} and body with size ${body?.length() ?: 0}&quot;)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_data">Sending data</h3>
<div class="paragraph">
<p>Using a channel to send data is quite straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">suspend fun sendChannel() {
  val stream = vertx.eventBus().publisher&lt;Double&gt;(&quot;temperature&quot;)
  val channel = stream.toChannel(vertx)

  while (true) {
    val temperature = readTemperatureSensor()

    // Broadcast the temperature
    // Non-blocking but could be suspended
    channel.send(temperature)

    // Wait for one second
    awaitEvent&lt;Long&gt; { vertx.setTimer(1000, it)  }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>SendChannel#send</code> and <code>WriteStream#write</code> are non blocking operations, however unlike <code>SendChannel#send</code>
can suspend the loop execution when the channel is full, the equivalent without a channel would look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Check we can write in the stream
if (stream.writeQueueFull()) {

  // We can't write so we set a drain handler to be called when we can write again
  stream.drainHandler { broadcastTemperature() }
} else {

  // Read temperature
  val temperature = readTemperatureSensor()

  // Write it to the stream
  stream.write(temperature)

  // Wait for one second
  vertx.setTimer(1000) {
    broadcastTemperature()
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rxjava_integration">RxJava integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The module <code>vertx-lang-kotlin-coroutines</code> does not have specific integration with RxJava however Kotlin coroutines
provide integration with RxJava, which works out nicely with <code>vertx-lang-kotlin-coroutines</code>.</p>
</div>
<div class="paragraph">
<p>You can read about it in the <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md">Guide to reactive streams with coroutines</a></p>
</div>
</div>
</div>

        

        
          <div id="footer">
            <div id="footer-text">
              
                Last updated 2018-02-02 13:50:38 CET
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="http://vertx.io/">Home</a></li>
          <li><a href="http://vertx.io/download/">Download</a></li>
          <li><a href="http://vertx.io/docs/3.5.0/">Documentation</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
          <li><a href="http://vertx.io/blog/">Blog</a></li>
          <li><a href="http://vertx.io/vertx2/" class="vertx-2-link">Vert.x 2</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="http://vertx.io/community/">Help &amp; Contributors</a></li>
          <li><a href="http://vertx.io/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual licensed under the <a href="https://www.eclipse.org/org/documents/epl-v10.php">Eclipse Public License 1.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="http://vertx.io/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="http://vertx.io/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="http://vertx.io/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script>
<script src="http://vertx.io/javascripts/bootstrap.min.js"></script>
<script src="http://vertx.io/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="http://vertx.io/javascripts/sidebar.js"></script>


</body>
</html>

