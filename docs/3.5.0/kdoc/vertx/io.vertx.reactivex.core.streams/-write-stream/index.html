<HTML>
<HEAD>
<meta charset="UTF-8">
<title>WriteStream - vertx</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">vertx</a>&nbsp;/&nbsp;<a href="../index.html">io.vertx.reactivex.core.streams</a>&nbsp;/&nbsp;<a href=".">WriteStream</a><br/>
<br/>
<h1>WriteStream</h1>
<code><span class="keyword">interface </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-stream-base/index.html"><span class="identifier">StreamBase</span></a></code>
<p>Represents a stream of data that can be written to. 
<p> Any class that implements this interface can be used by a io.vertx.reactivex.core.streams.Pump to pump data from a <code>ReadStream</code> to it. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.streams.WriteStream non RX-ified interface using Vert.x codegen.</p>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="drain-handler.html">drainHandler</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">drainHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$drainHandler(io.vertx.core.Handler((java.lang.Void)))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html"><span class="identifier">Void</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set a drain handler on the stream. If the write queue is full, then the handler will be called when the write queue is ready to accept buffers again. See io.vertx.reactivex.core.streams.Pump for an example of this being used.  The stream implementation defines when the drain handler, for example it could be when the queue size has been reduced to <code>maxSize / 2</code>.</p>
</td>
</tr>
<tr>
<td>
<p><a href="end.html">end</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">end</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Ends the stream. 
<p> Once the stream has ended, it cannot be used any more.</p>
</p>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">end</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$end(io.vertx.reactivex.core.streams.WriteStream.T)/t">t</span><span class="symbol">:</span>&nbsp;<span class="identifier">T</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Same as <code><a href="end.html">io.vertx.reactivex.core.streams.WriteStream#end</a></code> but writes some data to the stream before ending.</p>
</td>
</tr>
<tr>
<td>
<p><a href="exception-handler.html">exceptionHandler</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">exceptionHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$exceptionHandler(io.vertx.core.Handler((kotlin.Throwable)))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html"><span class="identifier">Throwable</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set an exception handler on the write stream.</p>
</td>
</tr>
<tr>
<td>
<p><a href="get-delegate.html">getDelegate</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getDelegate</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="new-instance.html">newInstance</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$newInstance(io.vertx.core.streams.WriteStream((kotlin.Any)))/arg">arg</span><span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$newInstance(io.vertx.core.streams.WriteStream((kotlin.Any)), io.vertx.lang.reactivex.TypeArg((io.vertx.reactivex.core.streams.WriteStream.newInstance.T)))/arg">arg</span><span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$newInstance(io.vertx.core.streams.WriteStream((kotlin.Any)), io.vertx.lang.reactivex.TypeArg((io.vertx.reactivex.core.streams.WriteStream.newInstance.T)))/__typeArg_T">__typeArg_T</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.lang.reactivex/-type-arg/index.html"><span class="identifier">TypeArg</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="set-write-queue-max-size.html">setWriteQueueMaxSize</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">setWriteQueueMaxSize</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$setWriteQueueMaxSize(kotlin.Int)/maxSize">maxSize</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set the maximum size of the write queue to <code>maxSize</code>. You will still be able to write to the stream even if there is more than <code>maxSize</code> items in the write queue. This is used as an indicator by classes such as <code>Pump</code> to provide flow control.  The value is defined by the implementation of the stream, e.g in bytes for a io.vertx.reactivex.core.net.NetSocket, the number of io.vertx.reactivex.core.eventbus.Message for a io.vertx.reactivex.core.eventbus.MessageProducer, etc...</p>
</td>
</tr>
<tr>
<td>
<p><a href="write.html">write</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">write</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.WriteStream$write(io.vertx.reactivex.core.streams.WriteStream.T)/data">data</span><span class="symbol">:</span>&nbsp;<span class="identifier">T</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Write some data to the stream. The data is put on an internal write queue, and the write actually happens asynchronously. To avoid running out of memory by putting too much on the write queue, check the <code><a href="write-queue-full.html">io.vertx.reactivex.core.streams.WriteStream#writeQueueFull</a></code> method before writing. This is done automatically if using a io.vertx.reactivex.core.streams.Pump.</p>
</td>
</tr>
<tr>
<td>
<p><a href="write-queue-full.html">writeQueueFull</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">writeQueueFull</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>This will return <code>true</code> if there are more bytes in the write queue than the value set using <code><a href="set-write-queue-max-size.html">io.vertx.reactivex.core.streams.WriteStream#setWriteQueueMaxSize</a></code></p>
</td>
</tr>
</tbody>
</table>
<h3>Inheritors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.file/-async-file/index.html">AsyncFile</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">AsyncFile</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a file on the file-system which can be read from, or written to asynchronously. 
<p> This class also implements io.vertx.reactivex.core.streams.ReadStream and io.vertx.reactivex.core.streams.WriteStream. This allows the data to be pumped to and from other streams, e.g. an io.vertx.reactivex.core.http.HttpClientRequest instance, using the io.vertx.reactivex.core.streams.Pump class </p>
 NOTE: This class has been automatically generated from the io.vertx.core.file.AsyncFile non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-client-request/index.html">HttpClientRequest</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClientRequest</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.http/-http-client-response/index.html"><span class="identifier">HttpClientResponse</span></a><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP request. 
<p> Instances are created by an io.vertx.reactivex.core.http.HttpClient instance, via one of the methods corresponding to the specific HTTP methods, or the generic request methods. On creation the request will not have been written to the wire. </p>
<p> Once a request has been obtained, headers can be set on it, and data can be written to its body if required. Once you are ready to send the request, one of the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> methods should be called. </p>
<p> Nothing is actually sent until the request has been internally assigned an HTTP connection. </p>
<p> The io.vertx.reactivex.core.http.HttpClient instance will return an instance of this class immediately, even if there are no HTTP connections available in the pool. Any requests sent before a connection is assigned will be queued internally and actually sent when an HTTP connection becomes available from the pool. </p>
<p> The headers of the request are queued for writing either when the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> method is called, or, when the first part of the body is written, whichever occurs first. </p>
<p> This class supports both chunked and non-chunked HTTP. </p>
<p> It implements io.vertx.reactivex.core.streams.WriteStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
<p> An example of using this class is as follows: </p>
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClientRequest non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-server-response/index.html">HttpServerResponse</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a server-side HTTP response. 
<p> An instance of this is created and associated to every instance of io.vertx.reactivex.core.http.HttpServerRequest that. </p>
<p> It allows the developer to control the HTTP response that is sent back to the client for a particular HTTP request. </p>
<p> It contains methods that allow HTTP headers and trailers to be set, and for a body to be written out to the response. </p>
<p> It also allows files to be streamed by the kernel directly from disk to the outgoing HTTP connection, bypassing user space altogether (where supported by the underlying operating system). This is a very efficient way of serving files from the server since buffers do not have to be read one by one from the file and written to the outgoing socket. </p>
<p> It implements io.vertx.reactivex.core.streams.WriteStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerResponse non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.kafka.client.producer/-kafka-producer/index.html">KafkaProducer</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">KafkaProducer</span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">KafkaProducerRecord</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Vert.x Kafka producer. 
<p> The provides global control over writing a record. </p>
 NOTE: This class has been automatically generated from the io.vertx.kafka.client.producer.KafkaProducer non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.eventbus/-message-producer/index.html">MessageProducer</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">MessageProducer</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">WriteStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Represents a stream of message that can be written to. 
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.eventbus.MessageProducer non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.net/-net-socket/index.html">NetSocket</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">NetSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a socket-like interface to a TCP connection on either the client or the server side. 
<p> Instances of this class are created on the client side by an io.vertx.reactivex.core.net.NetClient when a connection to a server is made, or on the server side by a io.vertx.reactivex.core.net.NetServer when a server accepts a connection. </p>
<p> It implements both and so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.net.NetSocket non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-web-socket-base/index.html">WebSocketBase</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">WebSocketBase</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-read-stream/index.html"><span class="identifier">ReadStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">WriteStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Base WebSocket implementation. 
<p> It implements both and so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.WebSocketBase non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
