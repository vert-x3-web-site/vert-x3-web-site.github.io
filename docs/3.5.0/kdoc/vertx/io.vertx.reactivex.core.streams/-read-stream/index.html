<HTML>
<HEAD>
<meta charset="UTF-8">
<title>ReadStream - vertx</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">vertx</a>&nbsp;/&nbsp;<a href="../index.html">io.vertx.reactivex.core.streams</a>&nbsp;/&nbsp;<a href=".">ReadStream</a><br/>
<br/>
<h1>ReadStream</h1>
<code><span class="keyword">interface </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-stream-base/index.html"><span class="identifier">StreamBase</span></a></code>
<p>Represents a stream of items that can be read from. 
<p> Any class that implements this interface can be used by a io.vertx.reactivex.core.streams.Pump to pump data from it to a io.vertx.reactivex.core.streams.WriteStream. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.streams.ReadStream non RX-ified interface using Vert.x codegen.</p>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="end-handler.html">endHandler</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">endHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$endHandler(io.vertx.core.Handler((java.lang.Void)))/endHandler">endHandler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html"><span class="identifier">Void</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set an end handler. Once the stream has ended, and there is no more data to be read, this handler will be called.</p>
</td>
</tr>
<tr>
<td>
<p><a href="exception-handler.html">exceptionHandler</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">exceptionHandler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$exceptionHandler(io.vertx.core.Handler((kotlin.Throwable)))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html"><span class="identifier">Throwable</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set an exception handler on the read stream.</p>
</td>
</tr>
<tr>
<td>
<p><a href="get-delegate.html">getDelegate</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getDelegate</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="handler.html">handler</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">handler</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$handler(io.vertx.core.Handler((io.vertx.reactivex.core.streams.ReadStream.T)))/handler">handler</span><span class="symbol">:</span>&nbsp;<span class="identifier">Handler</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Set a data handler. As data is read, the handler will be called with the data.</p>
</td>
</tr>
<tr>
<td>
<p><a href="new-instance.html">newInstance</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$newInstance(io.vertx.core.streams.ReadStream((kotlin.Any)))/arg">arg</span><span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">newInstance</span><span class="symbol">(</span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$newInstance(io.vertx.core.streams.ReadStream((kotlin.Any)), io.vertx.lang.reactivex.TypeArg((io.vertx.reactivex.core.streams.ReadStream.newInstance.T)))/arg">arg</span><span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="io.vertx.reactivex.core.streams.ReadStream$newInstance(io.vertx.core.streams.ReadStream((kotlin.Any)), io.vertx.lang.reactivex.TypeArg((io.vertx.reactivex.core.streams.ReadStream.newInstance.T)))/__typeArg_T">__typeArg_T</span><span class="symbol">:</span>&nbsp;<a href="../../io.vertx.lang.reactivex/-type-arg/index.html"><span class="identifier">TypeArg</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="pause.html">pause</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">pause</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Pause the <code>ReadSupport</code>. While it's paused, no data will be sent to the <code>dataHandler</code></p>
</td>
</tr>
<tr>
<td>
<p><a href="resume.html">resume</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">resume</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Resume reading. If the <code>ReadSupport</code> has been paused, reading will recommence on it.</p>
</td>
</tr>
<tr>
<td>
<p><a href="to-flowable.html">toFlowable</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">toFlowable</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html"><span class="identifier">Flowable</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="to-observable.html">toObservable</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">toObservable</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html"><span class="identifier">Observable</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Inheritors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.file/-async-file/index.html">AsyncFile</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">AsyncFile</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a file on the file-system which can be read from, or written to asynchronously. 
<p> This class also implements io.vertx.reactivex.core.streams.ReadStream and io.vertx.reactivex.core.streams.WriteStream. This allows the data to be pumped to and from other streams, e.g. an io.vertx.reactivex.core.http.HttpClientRequest instance, using the io.vertx.reactivex.core.streams.Pump class </p>
 NOTE: This class has been automatically generated from the io.vertx.core.file.AsyncFile non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.datagram/-datagram-socket/index.html">DatagramSocket</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">DatagramSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.datagram/-datagram-packet/index.html"><span class="identifier">DatagramPacket</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../../io.vertx.reactivex.core.metrics/-measured/index.html"><span class="identifier">Measured</span></a></code>
<p>A datagram socket can be used to send io.vertx.reactivex.core.datagram.DatagramPacket's to remote datagram servers and receive io.vertx.reactivex.core.datagram.DatagramPackets . 
<p> Usually you use a datagram socket to send UDP over the wire. UDP is connection-less which means you are not connected to the remote peer in a persistent way. Because of this you have to supply the address and port of the remote peer when sending data. </p>
<p> You can send data to ipv4 or ipv6 addresses, which also include multicast addresses. </p>
<p> Please consult the documentation for more information on datagram sockets. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.datagram.DatagramSocket non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-client-request/index.html">HttpClientRequest</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClientRequest</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.http/-http-client-response/index.html"><span class="identifier">HttpClientResponse</span></a><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP request. 
<p> Instances are created by an io.vertx.reactivex.core.http.HttpClient instance, via one of the methods corresponding to the specific HTTP methods, or the generic request methods. On creation the request will not have been written to the wire. </p>
<p> Once a request has been obtained, headers can be set on it, and data can be written to its body if required. Once you are ready to send the request, one of the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> methods should be called. </p>
<p> Nothing is actually sent until the request has been internally assigned an HTTP connection. </p>
<p> The io.vertx.reactivex.core.http.HttpClient instance will return an instance of this class immediately, even if there are no HTTP connections available in the pool. Any requests sent before a connection is assigned will be queued internally and actually sent when an HTTP connection becomes available from the pool. </p>
<p> The headers of the request are queued for writing either when the <code><a href="#">io.vertx.reactivex.core.http.HttpClientRequest#end</a></code> method is called, or, when the first part of the body is written, whichever occurs first. </p>
<p> This class supports both chunked and non-chunked HTTP. </p>
<p> It implements io.vertx.reactivex.core.streams.WriteStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
<p> An example of using this class is as follows: </p>
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClientRequest non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-client-response/index.html">HttpClientResponse</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpClientResponse</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a client-side HTTP response. 
<p> Vert.x provides you with one of these via the handler that was provided when creating the io.vertx.reactivex.core.http.HttpClientRequest or that was set on the io.vertx.reactivex.core.http.HttpClientRequest instance. </p>
<p> It implements io.vertx.reactivex.core.streams.ReadStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpClientResponse non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-server-file-upload/index.html">HttpServerFileUpload</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerFileUpload</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents an file upload from an HTML FORM.  NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerFileUpload non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-http-server-request/index.html">HttpServerRequest</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">HttpServerRequest</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a server-side HTTP request. 
<p> Instances are created for each request and passed to the user via a handler. </p>
<p> Each instance of this class is associated with a corresponding io.vertx.reactivex.core.http.HttpServerResponse instance via <code><a href="../../io.vertx.reactivex.core.http/-http-server-request/response.html">io.vertx.reactivex.core.http.HttpServerRequest#response</a></code>.</p>
<p> It implements io.vertx.reactivex.core.streams.ReadStream so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
<p> </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.HttpServerRequest non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.parsetools/-json-parser/index.html">JsonParser</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">JsonParser</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.parsetools/-json-event/index.html"><span class="identifier">JsonEvent</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>A parser class which allows to incrementally parse json elements and emit json parse events instead of parsing a json element fully. This parser is convenient for parsing large json structures.  The parser can also parse entire object or array when it is convenient, for instance a very large array of small objects can be parsed efficiently by handling array <em>start</em>/<em>end</em> and <em>object</em> events.  Whenever the parser fails to parse or process the stream, the <code><a href="#">io.vertx.reactivex.core.parsetools.JsonParser#exceptionHandler</a></code> is called with the cause of the failure and the current handling stops. After such event, the parser should not handle data anymore.  NOTE: This class has been automatically generated from the io.vertx.core.parsetools.JsonParser non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.kafka.client.consumer/-kafka-consumer/index.html">KafkaConsumer</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">KafkaConsumer</span><span class="symbol">&lt;</span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier">V</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">KafkaConsumerRecord</span><span class="symbol">&lt;</span><span class="identifier">K</span><span class="symbol">,</span>&nbsp;<span class="identifier">V</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Vert.x Kafka consumer. 
<p> You receive Kafka records by providing a <code><a href="#">io.vertx.reactivex.kafka.client.consumer.KafkaConsumer#handler</a></code>. As messages arrive the handler will be called with the records. </p>
<p> The <code><a href="../../io.vertx.reactivex.kafka.client.consumer/-kafka-consumer/pause.html">io.vertx.reactivex.kafka.client.consumer.KafkaConsumer#pause</a></code> and <code><a href="../../io.vertx.reactivex.kafka.client.consumer/-kafka-consumer/resume.html">io.vertx.reactivex.kafka.client.consumer.KafkaConsumer#resume</a></code> provides global control over reading the records from the consumer. </p>
<p> The <code><a href="../../io.vertx.reactivex.kafka.client.consumer/-kafka-consumer/pause.html">io.vertx.reactivex.kafka.client.consumer.KafkaConsumer#pause</a></code> and <code><a href="../../io.vertx.reactivex.kafka.client.consumer/-kafka-consumer/resume.html">io.vertx.reactivex.kafka.client.consumer.KafkaConsumer#resume</a></code> provides finer grained control over reading records for specific Topic/Partition, these are Kafka's specific operations. </p>
 NOTE: This class has been automatically generated from the io.vertx.kafka.client.consumer.KafkaConsumer non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.eventbus/-message-consumer/index.html">MessageConsumer</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">MessageConsumer</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.eventbus/-message/index.html"><span class="identifier">Message</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>An event bus consumer object representing a stream of message to an io.vertx.reactivex.core.eventbus.EventBus address that can be read from. 
<p> The <code><a href="#">io.vertx.reactivex.core.eventbus.EventBus#consumer</a></code> or <code><a href="#">io.vertx.reactivex.core.eventbus.EventBus#localConsumer</a></code> creates a new consumer, the returned consumer is not yet registered against the event bus. Registration is effective after the <code><a href="#">io.vertx.reactivex.core.eventbus.MessageConsumer#handler</a></code> method is invoked.</p>
<p> The consumer is unregistered from the event bus using the <code><a href="../../io.vertx.reactivex.core.eventbus/-message-consumer/unregister.html">io.vertx.reactivex.core.eventbus.MessageConsumer#unregister</a></code> method or by calling the <code><a href="#">io.vertx.reactivex.core.eventbus.MessageConsumer#handler</a></code> with a null value.. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.eventbus.MessageConsumer non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.net/-net-socket/index.html">NetSocket</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">NetSocket</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Represents a socket-like interface to a TCP connection on either the client or the server side. 
<p> Instances of this class are created on the client side by an io.vertx.reactivex.core.net.NetClient when a connection to a server is made, or on the server side by a io.vertx.reactivex.core.net.NetServer when a server accepts a connection. </p>
<p> It implements both and so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.net.NetSocket non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.parsetools/-record-parser/index.html">RecordParser</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">RecordParser</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">Handler</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>A helper class which allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed size records. 
<p> Instances of this class take as input io.vertx.reactivex.core.buffer.Buffer instances containing raw bytes, and output records. </p>
<p> For example, if I had a simple ASCII text protocol delimited by '\n' and the input was the following: </p>
<p> </p>
<pre><code> buffer1:HELLO\nHOW ARE Y buffer2:OU?\nI AM buffer3: DOING OK buffer4:\n </code></pre> Then the output would be:
<p> </p>
<pre><code> buffer1:HELLO buffer2:HOW ARE YOU? buffer3:I AM DOING OK </code></pre> Instances of this class can be changed between delimited mode and fixed size record mode on the fly as individual records are read, this allows you to parse protocols where, for example, the first 5 records might all be fixed size (of potentially different sizes), followed by some delimited records, followed by more fixed size records. 
<p> Instances of this class can't currently be used for protocols where the text is encoded with something other than a 1-1 byte-char mapping. </p>
<p> Please see the documentation for more information. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.parsetools.RecordParser non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.ext.sql/-s-q-l-row-stream/index.html">SQLRowStream</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">SQLRowStream</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><span class="identifier">JsonArray</span><span class="symbol">&gt;</span></code>
<p>A ReadStream of Rows from the underlying RDBMS. This class follows the ReadStream semantics and will automatically close the underlying resources if all returned rows are returned. For cases where the results are ignored before the full processing of the returned rows is complete the close method **MUST** be called in order to release underlying resources. The interface is minimal in order to support all SQL clients not just JDBC.  NOTE: This class has been automatically generated from the io.vertx.ext.sql.SQLRowStream non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.ext.unit.report/-test-suite-report/index.html">TestSuiteReport</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">TestSuiteReport</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.ext.unit.report/-test-case-report/index.html"><span class="identifier">TestCaseReport</span></a><span class="symbol">&gt;</span></code>
<p>The test suite reports is basically a stream of events reporting the test suite execution.  NOTE: This class has been automatically generated from the io.vertx.ext.unit.report.TestSuiteReport non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core/-timeout-stream/index.html">TimeoutStream</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">TimeoutStream</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html"><span class="identifier">Long</span></a><span class="symbol">&gt;</span></code>
<p>A timeout stream is triggered by a timer, the io.vertx.reactivex.core.Handler will be call when the timer is fired, it can be once or several times depending on the nature of the timer related to this stream. The will be called after the timer handler has been called. 
<p> Pausing the timer inhibits the timer shots until the stream is resumed. Setting a null handler callback cancels the timer. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.TimeoutStream non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../io.vertx.reactivex.core.http/-web-socket-base/index.html">WebSocketBase</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">WebSocketBase</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">ReadStream</span><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><a href="../-write-stream/index.html"><span class="identifier">WriteStream</span></a><span class="symbol">&lt;</span><a href="../../io.vertx.reactivex.core.buffer/-buffer/index.html"><span class="identifier">Buffer</span></a><span class="symbol">&gt;</span></code>
<p>Base WebSocket implementation. 
<p> It implements both and so it can be used with io.vertx.reactivex.core.streams.Pump to pump data with flow control. </p>
 NOTE: This class has been automatically generated from the io.vertx.core.http.WebSocketBase non RX-ified interface using Vert.x codegen.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
